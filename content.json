{"meta":{"title":"YuXiao's blog","subtitle":null,"description":null,"author":"肖宇","url":"http://xiaoyu666.com"},"pages":[{"title":"关于","date":"2018-07-09T03:40:15.614Z","updated":"2018-07-09T03:40:15.614Z","comments":true,"path":"about/index.html","permalink":"http://xiaoyu666.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-08-09T06:40:22.000Z","updated":"2018-07-09T03:40:15.614Z","comments":false,"path":"categories/index.html","permalink":"http://xiaoyu666.com/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2018-07-09T03:40:15.614Z","updated":"2018-07-09T03:40:15.614Z","comments":true,"path":"links/index.html","permalink":"http://xiaoyu666.com/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-08-09T06:15:51.000Z","updated":"2018-07-09T03:40:15.614Z","comments":false,"path":"tags/index.html","permalink":"http://xiaoyu666.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自定义同步和异步 NSOperation 代码模板","slug":"自定义同步和异步-NSOperation-代码模板","date":"2018-05-16T09:29:36.000Z","updated":"2018-07-09T03:40:15.613Z","comments":true,"path":"2018/05/16/自定义同步和异步-NSOperation-代码模板/","link":"","permalink":"http://xiaoyu666.com/2018/05/16/自定义同步和异步-NSOperation-代码模板/","excerpt":"同步的 NSOperation在实际情况中，定义同步的 NSOperation 比较简单，不需要显式的设置 finish 的值 同步的 NSOperation 模板 .h123456#import &lt;Foundation/Foundation.h&gt;//非并发@interface XXXOperation : NSOperation@end","text":"同步的 NSOperation在实际情况中，定义同步的 NSOperation 比较简单，不需要显式的设置 finish 的值 同步的 NSOperation 模板 .h123456#import &lt;Foundation/Foundation.h&gt;//非并发@interface XXXOperation : NSOperation@end .m123456789101112131415161718192021222324252627282930313233343536373839404142@interface XXXOperation ()@end@implementation XXXOperation#pragma mark -- (void)start &#123; NSLog(@&quot;main&quot;); @try &#123; @autoreleasepool &#123; //添加自动释放池 是因为 子线程拿不到主线程的自动释放池 if ([self isCancelled]) &#123; NSLog(@&quot;======&gt;&gt;[operation] operation isCancelled YES&quot;); return; &#125; else &#123; NSLog(@&quot;======&gt;&gt; [operation] operation start&quot;); NSInteger i = 0; while (i &lt; 5)&#123; NSLog(@&quot;i : %ld&quot;,(long)i); i++; &#125; &#125; &#125; &#125; @catch (NSException *exception) &#123; NSLog(@&quot;======&gt;&gt; [operation] exception catch&quot;); &#125; NSLog(@&quot;======&gt;&gt; [operation] operation finished&quot;);&#125;- (void)cancel &#123; [super cancel];&#125;- (void)dealloc &#123; [self timerTimeoutInvalid]; NSLog(@&quot;======&gt;&gt;[operation] operation:%p dealloc &quot;,self);&#125;@end 异步的 NSOperation异步的 NSOperation 场景从字面上不是非常容易理解，简单来说： 1234我需要构建一个线程池，该线程池用来从网络下下载图片，考虑到性能的需求，我需要能够动态的设置线程池能同时下载图片的数量现在假设这个数量默认为3个，即我需要开启三个 NSOperation 来下载图片现在问题来了，下载图片这个过程显然使异步的，在同步的 NSOperation 中已经不能满足我们的需求所以，异步的NSOperation就成了解决方案 从苹果的官方文档上，我们可以看出来 NSOperation 的结束是由 finished 方法来进行判定在 NSOperation 中 finished 的getter方法是 isFinished 下面是一个异步的 NSOperation 模板 .h123456#import &lt;Foundation/Foundation.h&gt;//非并发@interface XXXOperation : NSOperation@end .m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@interface XXXOperation ()// getter=isFinished 必须指定，如果不指定需要 子类覆写 isFinished 方法// getter=isExecuting 同上@property (nonatomic, assign, getter=isFinished) BOOL finished;@property (nonatomic, assign, getter=isExecuting) BOOL executing;@end@implementation XXXOperation@synthesize finished = _finished;@synthesize executing = _executing;#pragma mark -- (void)start &#123; NSLog(@&quot;main&quot;); @try &#123; @autoreleasepool &#123; //添加自动释放池 是因为 子线程拿不到主线程的自动释放池 if ([self isCancelled]) &#123; NSLog(@&quot;======&gt;&gt;[operation] operation isCancelled YES&quot;); self.finished = YES; return; &#125; else &#123; self.executing = YES; NSLog(@&quot;======&gt;&gt;[operation] operation starting...&quot;); @weakify(self); void (^block)() = ^()&#123; @strongify(self); self.finished = YES; self.executing = NO; &#125;; [self startOperationComplete:block]; &#125; &#125; &#125; @catch (NSException *exception) &#123; NSLog(@&quot;======&gt;&gt; [operation] exception catch&quot;); self.finished = YES; self.executing = NO; &#125;&#125;- (void)startOperationComplete:(void(^)())complete &#123; //测试代码 NSLog(@&quot;======&gt;&gt; [operation] operation started&quot;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_current_queue(), ^&#123; if (complete) complete(); &#125;);&#125;- (void)setFinished:(BOOL)finished &#123; NSLog(@&quot;======&gt;&gt; [operation] operation will finish&quot;); [self willChangeValueForKey:@&quot;isFinished&quot;]; _finished = finished; [self didChangeValueForKey:@&quot;isFinished&quot;]; NSLog(@&quot;======&gt;&gt; [operation] operation finished&quot;);&#125;- (void)setExecuting:(BOOL)executing &#123; [self willChangeValueForKey:@&quot;isExecuting&quot;]; _executing = executing; [self didChangeValueForKey:@&quot;isExecuting&quot;];&#125;- (void)cancel &#123; [super cancel]; NSLog(@&quot;======&gt;&gt; [operation] cancel&quot;); // 如果正在执行中则表示已经start过，可以将isFinished设为yes [self timerTimeoutInvalid]; if (self.isExecuting) &#123; self.finished = YES; self.executing = NO; &#125;&#125;- (void)dealloc &#123; [self timerTimeoutInvalid]; NSLog(@&quot;======&gt;&gt;[operation] operation:%p dealloc &quot;,self);&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"http://xiaoyu666.com/tags/多线程/"}]},{"title":"BlockMarcoUnit @weakify @strongify 一个快速防止 block retain cycle 的开源 marco","slug":"BlockMarcoUnit @weakify @strongify 一个快速防止 block retain cycle 的开源 marco","date":"2018-02-05T08:31:59.000Z","updated":"2018-07-09T03:40:15.606Z","comments":true,"path":"2018/02/05/BlockMarcoUnit @weakify @strongify 一个快速防止 block retain cycle 的开源 marco/","link":"","permalink":"http://xiaoyu666.com/2018/02/05/BlockMarcoUnit @weakify @strongify 一个快速防止 block retain cycle 的开源 marco/","excerpt":"项目下载地址 [https://github.com/levinXiao/BlockMacroUnit] 循环引用（retain cycle）的由来和一般解决方案在block语句块中，如果需引用self，而self对象中又持有block对象，就会造成循环引用循环引用(retain cycle)，导致内存泄露，比如以下代码 123self.block = ^&#123; [self dosomething];&#125;;","text":"项目下载地址 [https://github.com/levinXiao/BlockMacroUnit] 循环引用（retain cycle）的由来和一般解决方案在block语句块中，如果需引用self，而self对象中又持有block对象，就会造成循环引用循环引用(retain cycle)，导致内存泄露，比如以下代码 123self.block = ^&#123; [self dosomething];&#125;; 一般我们是这么解决的 1234__weak typeof(self) weakSelf = self;self.block = ^&#123; [weakSelf dosomething];&#125;; 这样虽然可以在编译时使 Xcode 不报错但是在运行时，也可能会因为 self 的释放导致 dosomething 这个方法不能够执行。要解决上述问题，需要在 block 内部将 weakself 重新变为强引用，这样 self 的释放才会在执行完 block 后被正确的释放 12345__weak typeof(self) weakSelf = self;self.block = ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; [strongSelf dosomething];&#125;;&#125; 为什么使用 BlockMarcoUnit在实际使用中，如果在每个 block 前后都添加这两句会显得比较繁琐在查看了 RAC 中相关的源码后，发现有一种简便的方法可是使用这种特性 123456789#import &quot;BlockMarco.h&quot;@weakify(self)dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @strongify(self) [self doSomething]; [self doOtherThing];&#125;); 暂时就说这么多吧，如果有什么问题欢迎随时在 github 上 issue 或者 email xiaoamani@qq.com","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"}]},{"title":"iOS 中 copy 和 mutableCopy 以及 one-level-deep-copy 进阶","slug":"iOS 中 copy 和 mutableCopy 以及 one-level-deep-copy 进阶","date":"2018-02-01T07:29:20.000Z","updated":"2018-07-09T03:40:15.609Z","comments":true,"path":"2018/02/01/iOS 中 copy 和 mutableCopy 以及 one-level-deep-copy 进阶/","link":"","permalink":"http://xiaoyu666.com/2018/02/01/iOS 中 copy 和 mutableCopy 以及 one-level-deep-copy 进阶/","excerpt":"iOS 中 copy 和 mutableCopy 以及 one-level-deep-copy 进阶对 copy 和 mutableCopy 的概念还有一些不了解的同学，可以看看这篇文章https://www.jianshu.com/p/700f58eb0b86 有了上面的了解之后，我们看看这段代码 123456789101112NSMutableArray *eleInMutable = [NSMutableArray arrayWithObject:@&quot;1&quot;];//二维数组NSMutableArray *array1 = [NSMutableArray arrayWithObject:eleInMutable];//NSMutableArray *array2 = array1.mutableCopy;//像二维数组的第一个元素数组添加一个2[array2[0] addObject:@&quot;2&quot;];printPointer(array1);/* print result : 0x10070ec50 */printPointer(array2);/* print result : 0x10070ec80 */","text":"iOS 中 copy 和 mutableCopy 以及 one-level-deep-copy 进阶对 copy 和 mutableCopy 的概念还有一些不了解的同学，可以看看这篇文章https://www.jianshu.com/p/700f58eb0b86 有了上面的了解之后，我们看看这段代码 123456789101112NSMutableArray *eleInMutable = [NSMutableArray arrayWithObject:@&quot;1&quot;];//二维数组NSMutableArray *array1 = [NSMutableArray arrayWithObject:eleInMutable];//NSMutableArray *array2 = array1.mutableCopy;//像二维数组的第一个元素数组添加一个2[array2[0] addObject:@&quot;2&quot;];printPointer(array1);/* print result : 0x10070ec50 */printPointer(array2);/* print result : 0x10070ec80 */ 在这里我们可以看到 pointer 的结果却是是不一样的。 但是！！！！！！！ 如果我们打印 array1 和 array2 的结果 1234printArray(array1);/* print result : [[&quot;1&quot;,&quot;2&quot;]] */printArray(array2);/* print result : [[&quot;1&quot;,&quot;2&quot;]] */ 会惊奇的发现 array1 的结果 和 array2 的结果完全一样 这不科学，我一定是眼花了！！！！！！ 不死心的我打印了 array1 和 array2 这两个二维数组的子数组的指针 1234printPointer(array1[0]);/* print result : 0x10070ee40 */printPointer(array2[0]);/* print result : 0x10070ee40 */ 居然完全一样，居然，会是，一样！！！！！！！！ one-level-deep copy查看了苹果官方文档后，找到了对应的说明 12345678910111213There are two ways to make deep copies of a collection.You can use the collection’s equivalent of initWithArray:copyItems: with YES as the second parameter.If you create a deep copy of a collection in this way,each object in the collection is sent a copyWithZone: message.If the objects in the collection have adopted the NSCopying protocol,the objects are deeply copied to the new collection,which is then the sole owner of the copied objects.If the objects do not adopt the NSCopying protocol,attempting to copy them in such a way results in a runtime error.However, copyWithZone: produces a shallow copy.This kind of copy is only capable of producing a one-level-deep copy.If you only need a one-level-deep copy,you can explicitly call for one as in Listing 2 发现了一个新的名词one-level-deep copy这个就是本文讨论的主题了 one-level-deep copy 是什么one-level-deep copy 从字面上理解，可以理解为单层深复制。那 deep copy 我们就换一种说法，叫做完全复制。 从苹果的官方文档来看，在 类集合元素 进行 mutableCopy 的时候，编译器会自动的进行单层深复制。在非类集合元素 进行 mutableCopy 的时候，编译器就会进行完全复制了。 那这样就解释的通本文开头所展示的代码了。 类集合元素的完全复制那如果我们在实际项目的使用中，如果要对类集合元素进行完全复制，苹果官方文档也给出了答案 方法1： 1NSArray *deepCopyArray=[[NSArray alloc] initWithArray:someArray copyItems:YES]; 当 copyItems 参数为 YES 的时候，会进行完全复制。同理，当 copyItems 参数为 NO 的时候，会进行单层深复制。 方法2： 12NSArray* trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData: [NSKeyedArchiver archivedDataWithRootObject:oldArray]]; 注意：要使用 NSKeyedUnarchiver 序列化对象要对对象实现 NSCoding 协议，当然，Foundation 库的 类集合元素（NSArray及其子类,NSSet及其子类,NSDictionary及其子类） 都实现了 NSCoding 协议 结语没有结语，只有代码 完整项目下载 示例代码： 12345678910111213141516171819202122232425NSMutableArray *eleInMutable = [NSMutableArray arrayWithObject:@&quot;1&quot;];//二维数组NSMutableArray *array1 = [NSMutableArray arrayWithObject:eleInMutable];//NSMutableArray *array2 = array1.mutableCopy;//像二维数组的第一个元素数组添加一个2[array2[0] addObject:@&quot;2&quot;];//开始验证 mutablecopy 是否是深复制//如果是深复制 那么 array2[0]中添加元素不会影响 array1的结果printPointer(array1);/* print result : 0x10070ec50 */printPointer(array2);/* print result : 0x10070ec80 */printArray(array1);/* print result : [[&quot;1&quot;,&quot;2&quot;]] */printArray(array2);/* print result : [[&quot;1&quot;,&quot;2&quot;]] */printPointer(array1[0]);/* print result : 0x10070ee40 */printPointer(array2[0]);/* print result : 0x10070ee40 */","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"}]},{"title":"OC 一些用过的觉得还不错的开源库","slug":"OC-一些用过的觉得还不错的开源库","date":"2018-01-08T07:51:09.000Z","updated":"2018-07-09T03:40:15.607Z","comments":true,"path":"2018/01/08/OC-一些用过的觉得还不错的开源库/","link":"","permalink":"http://xiaoyu666.com/2018/01/08/OC-一些用过的觉得还不错的开源库/","excerpt":"AFNetWorkinghttps://github.com/AFNetworking/AFNetworking AYPageControlViewhttps://github.com/AYJk/AYPageControl这个是pagecontroll的动画封装库 该库实现了一个滑动的动画效果 DZNEmptyDataSethttps://github.com/dzenbot/DZNEmptyDataSet这个是tableview加载空数据的时候能够用上的一个库","text":"AFNetWorkinghttps://github.com/AFNetworking/AFNetworking AYPageControlViewhttps://github.com/AYJk/AYPageControl这个是pagecontroll的动画封装库 该库实现了一个滑动的动画效果 DZNEmptyDataSethttps://github.com/dzenbot/DZNEmptyDataSet这个是tableview加载空数据的时候能够用上的一个库 ZXingObjChttps://github.com/TheLevelUp/ZXingObjC二维码生成和使用使用的库 LBXScanhttps://github.com/MxABC/LBXScan二维码生成和使用 对ZXingObjC的带UI的封装 实现了(二维码、扫码、扫一扫、ZXing和ios系统自带扫码封装，扫码界面效果封装) FDFullscreenPopGesturehttps://github.com/forkingdog/FDFullscreenPopGesture将NavigationController的侧边右滑返回手势扩展为全屏幕或者指定距离生效的手势 ViewDeckhttps://github.com/ViewDeck/ViewDeck侧边栏组件 TPKeyboardAvoidinghttps://github.com/michaeltyson/TPKeyboardAvoiding一个很好的在tableview scrollerview中管理键盘使之不遮挡视图的库 fmdbhttps://github.com/ccgus/fmdbiOS上一个很好的sqlite数据库开源库 LKDBHelperhttps://github.com/li6185377/LKDBHelper-SQLite-ORM在model对象中创建DB支持 是对fmdb的封装 CTAssetsPickerControllerhttps://github.com/chiunam/CTAssetsPickerControlleriOS中选择相册和图库中的一个很好的封装库 ijkplayerhttps://github.com/Bilibili/ijkplayer/基于FFmepg的开源视频流播放器 可以边下边播url视频 还可以播放基于RTMP协议的直播流视频 bilibili开源 KRVideoPlayerhttps://github.com/36Kr-Mobile/KRVideoPlayer基于iOS标准的AVKit封装的播放视频的库,36Kr开源,优点是相比于ijkplayer非常轻量很纯粹,但是缺点是功能不如它强大,并且截至20160926还没有针对设备的旋转做出优化,全屏也不够完善,只是一个简单的旋转视图,看起来很怪,希望能完善吧 SAMKeychainhttps://github.com/soffes/SAMKeychain基于keychain的封装,用于持久化数据并加密 不随应用的卸载而丢失 DKNightVersionhttps://github.com/Draveness/DKNightVersion非常成熟的夜间模式解决方案的开源库 能够很好的支持第三方库的模式切换 FDFullscreenPopGesturehttps://github.com/forkingdog/FDFullscreenPopGesture能够扩展到全屏的右滑返回上一页的手势,是iOS中侧滑返回的扩展 TZScrollViewPopGesturehttps://github.com/banchichen/TZScrollViewPopGesture让iOS的侧滑返回上一页和scrollview能够共存且不受影响,和FDFullscreenPopGesture共存不冲突 FLAnimatedImagehttps://github.com/Flipboard/FLAnimatedImageFLAnimatedImage 是 iOS 的一个渲染 Gif 动画的引擎。可同时播放多个Gif 动画，速度媲美桌面浏览器,可变帧延迟,内存占用小,可在第一次循环播放时消除或者阻止延迟,动画的帧延迟解析性能媲美浏览器","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"}]},{"title":" SSH 登录失败：Host key verification failed 的处理方法","slug":"SSH-登录失败：Host-key-verification-failed-的处理方法","date":"2017-12-14T09:00:00.000Z","updated":"2018-07-09T03:40:15.608Z","comments":true,"path":"2017/12/14/SSH-登录失败：Host-key-verification-failed-的处理方法/","link":"","permalink":"http://xiaoyu666.com/2017/12/14/SSH-登录失败：Host-key-verification-failed-的处理方法/","excerpt":"SSH 登录失败：Host key verification failed由于公钥不一样了，所以无法登录，提示信息是 KEY 验证失败。解决方法是：","text":"SSH 登录失败：Host key verification failed由于公钥不一样了，所以无法登录，提示信息是 KEY 验证失败。解决方法是： 在 /root/.ssh/known_hosts 文件里面将原来的公钥信息删除即可。SSH 报 Host key verification failed.一般来说，出现该错误有这么几种可能: ssh/known_hosts 裡面记录的目标主机 key 值不正确。这是最普遍的情况，只要删除对应的主机记录就能恢复正常。 ssh 目录或者 .ssh/known_hosts 对当前用户的权限设置不正确。这种情况比较少，一般正确设置读写权限以后也能恢复正常。 /dev/tty 对 other 用户没有放开读写权限。这种情况极为罕见。出现的现象是，只有 root 用户能够使用 ssh client，而所有其他的普通用户都会出现错误。修改 /dev/tty 的权限后，一切正常。","categories":[{"name":"linux","slug":"linux","permalink":"http://xiaoyu666.com/categories/linux/"}],"tags":[{"name":"error","slug":"error","permalink":"http://xiaoyu666.com/tags/error/"},{"name":"ssh","slug":"ssh","permalink":"http://xiaoyu666.com/tags/ssh/"}]},{"title":"Xcode中SVN提交不了.a文件的解决方法","slug":"Xcode中SVN提交不了.a文件的解决方法","date":"2017-11-25T13:14:52.000Z","updated":"2018-07-09T03:40:15.609Z","comments":true,"path":"2017/11/25/Xcode中SVN提交不了.a文件的解决方法/","link":"","permalink":"http://xiaoyu666.com/2017/11/25/Xcode中SVN提交不了.a文件的解决方法/","excerpt":"在Xcode中使用svn的时候 发现.a文件都提交不上去原因是在svn中 .a文件是默认忽略的知道这个原理后我们只要在svn的忽略文件中移除.a文件就可以了 输入vi ~/.subversion/config 打开svn配置文件找到global-ignores 1#*.rej *~ #*# .#* .*.swp .DS_Store","text":"在Xcode中使用svn的时候 发现.a文件都提交不上去原因是在svn中 .a文件是默认忽略的知道这个原理后我们只要在svn的忽略文件中移除.a文件就可以了 输入vi ~/.subversion/config 打开svn配置文件找到global-ignores 1#*.rej *~ #*# .#* .*.swp .DS_Store 删除 *.a这一串就可以了 当这样使用后发现还是不能够添加上去所以你还需要手动添加追踪和手动提交 1.打开终端，输入cd，空格，然后将需要上传的.a文件所在的文件夹（不是.a文件）拖拽到终端（此办法无需输入繁琐的路径，快捷方便） ，回车；2.之后再输入如下命令：svn add **.a，回车；3.之后会出现：A (bin) libOCMock.a 表示添加成功刚才添加的.a文件，此时就可以手动上传了。 另外，在mac 10.8中输入命令行，可能会提示你command not found，因为10.8默认没有安装Command line tools，解决办法：command not found解决方法。 4.输入 svn ci - m “”提交","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"svn,macOS,Xcode","slug":"svn-macOS-Xcode","permalink":"http://xiaoyu666.com/tags/svn-macOS-Xcode/"}]},{"title":"iOS真机抓包命令rvictl","slug":"iOS真机抓包命令rvictl","date":"2017-10-21T10:04:01.000Z","updated":"2018-07-09T03:40:15.610Z","comments":true,"path":"2017/10/21/iOS真机抓包命令rvictl/","link":"","permalink":"http://xiaoyu666.com/2017/10/21/iOS真机抓包命令rvictl/","excerpt":"iOS 5后，apple引入了RVI remote virtual interface的特性，它只需要将iOS设备使用USB数据线连接到mac上，然后使用rvictl工具以iOS设备的UDID为参数在Mac中建立一个虚拟网络接口rvi，就可以在mac设备上使用tcpdump，wireshark等工具对创建的接口进行抓包分析了。","text":"iOS 5后，apple引入了RVI remote virtual interface的特性，它只需要将iOS设备使用USB数据线连接到mac上，然后使用rvictl工具以iOS设备的UDID为参数在Mac中建立一个虚拟网络接口rvi，就可以在mac设备上使用tcpdump，wireshark等工具对创建的接口进行抓包分析了。 这种流量分析方法，是直接捕捉的iOS设备上的网络流量，因此无论是wifi还是2G/3G等其他网络类型都可以捕捉到，一根USB数据线就搞定了，不需要苛刻的要求PC与iOS设备处于同一个网段，或必须越狱等局限了 1.将iOS设备使用usb连接到mac上 2.获取设备的udid,自行百度 3.创建rvi接口$ rvictl -s ($UDID) 4.使用wireshark或者tcpdump来进行抓包 5.结束后,移除rvi端口$ rvictl -x ($UDID)","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"网络抓包","slug":"网络抓包","permalink":"http://xiaoyu666.com/tags/网络抓包/"}]},{"title":"在UILabel中用富文本NSMutableAttributedString和NSTextAttachment实现最简单的图文混排","slug":"在UILabel中用富文本NSMutableAttributedString和NSTextAttachment实现最简单的图文混排","date":"2017-09-12T07:33:28.000Z","updated":"2018-07-09T03:40:15.612Z","comments":true,"path":"2017/09/12/在UILabel中用富文本NSMutableAttributedString和NSTextAttachment实现最简单的图文混排/","link":"","permalink":"http://xiaoyu666.com/2017/09/12/在UILabel中用富文本NSMutableAttributedString和NSTextAttachment实现最简单的图文混排/","excerpt":"在iOS6之后 UILabel API中添加了一个属性 attributedText","text":"在iOS6之后 UILabel API中添加了一个属性 attributedText 1234// the underlying attributed string drawn by the label, if set, the label ignores the properties above.//如果设置了这个属性 label会一些其他的属性而直接使用这个属性来渲染文字 忽略的属性包括但不限于 text,font,textColor,shadowColor,shadowColor,shadowOffset,textAlignment,lineBreakMode@property(nullable, nonatomic,copy) NSAttributedString *attributedText NS_AVAILABLE_IOS(6_0); // default is nil 现在要实现在UILabel中直接使用一些简单的图文混排 我们就是利用的这个属性来实现 1234567891011NSTextAttachment *attch = [[NSTextAttachment alloc] init];attch.image = [UIImage imageNamed:@&quot;d_aini&quot;];//设置图片大小attch.bounds = CGRectMake(0, 0, 32, 32);//创建带有图片的富文本NSAttributedString *string = [NSAttributedString attributedStringWithAttachment:attch];[attri appendAttributedString:string];// 用label的attributedText属性来使用富文本label.attributedText = attri; NSMutableAttributedString的一些其他的用法 1234567891011// 创建一个富文本NSMutableAttributedString *attri = [[NSMutableAttributedString alloc] initWithString:@&quot;哈哈哈哈哈123456789&quot;];// 修改富文本中的不同文字的样式//设置前景色[attri addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(0, 5)];//设置字体[attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:20] range:NSMakeRange(0, 5)];// 设置数字为红色[attri addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(5, 9)];//设置字体[attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(5, 9)];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"图文混排","slug":"图文混排","permalink":"http://xiaoyu666.com/tags/图文混排/"}]},{"title":"iOS图片拉伸技巧—— resizableImageWithCapInsets","slug":"iOS图片拉伸技巧—— resizableImageWithCapInsets","date":"2017-05-12T13:14:52.000Z","updated":"2018-07-09T03:40:15.610Z","comments":true,"path":"2017/05/12/iOS图片拉伸技巧—— resizableImageWithCapInsets/","link":"","permalink":"http://xiaoyu666.com/2017/05/12/iOS图片拉伸技巧—— resizableImageWithCapInsets/","excerpt":"原先以为很简单的东西，到了实际做的时候，才发现这里出错那里不对。浪费很多时间，究根结底，还是没有弄清楚文档。 在iOS5, UIImage添加了可以拉伸图片的函数，即：1[UIImage resizableImageWithCapInsets:(UIEdgeInset)&#123;#top#,#left#,#bottom#,#right#&#125;]","text":"原先以为很简单的东西，到了实际做的时候，才发现这里出错那里不对。浪费很多时间，究根结底，还是没有弄清楚文档。 在iOS5, UIImage添加了可以拉伸图片的函数，即：1[UIImage resizableImageWithCapInsets:(UIEdgeInset)&#123;#top#,#left#,#bottom#,#right#&#125;] UIEdgeInset 是一个结构体 定义如下:1234567Creates and returns a new image object with the specified cap insets.DiscussionYou use this method to add cap insets to an image or to change the existing cap insets of an image. In both cases, you get back a new image and the original image remains untouched.During scaling or resizing of the image, areas covered by a cap are not scaled or resized. Instead, the pixel area not covered by the cap in each direction is tiled, left-to-right and top-to-bottom, to resize the image. This technique is often used to create variable-width buttons, which retain the same rounded corners but whose center region grows or shrinks as needed. For best performance, use a tiled area that is a 1×1 pixel area in size. 上左下右4参数定义了cap inset，就是离四条边的距离。拉升时，cap到边的部分不会被拉升，其余部分则会被拉升。尤其需要注意的时，拉升的时候，是从左到右，从上到下的方向。通俗点说，拉升不是全方向的拉升，而是垂直和水平拉升的叠加。 开始我设置参数{20,10,10,10}，在图上的位置大致： 这样拉升的结果： 很奇怪是不是，为什么出现了两个箭头（红色部分是设置的背景色用语区分）？再回头看下文档，才恍然大悟： 1.拉升的时候，是按前文说的两个方向来拉升2.拉升的部分，是以tiled方式，简单的说就是以镜像的方式 按照1的规则，拉升的时候，水平和垂直方向都需要拉升。这样在水平拉升的时候，箭头其实处于拉升的部分。而拉升的时候，先按照原有的尺寸添加进去，不足的地方再把中间不拉升的部分填充进去，周而复始，直到填充完毕。因此，就有上面的现象了。 要达到需要的效果，必须按照如下的设置： ![4] (http://o7b4rtbje.bkt.clouddn.com/imageRight.png) 于是得到了我们需要的效果： 说实话，这个函数在iOS5 beta的时候就知道了，可是一直是不正确的理解。直到今天需要用到的时候，才发现一直没理解对。于此同时，也发现自己 局限在工作相关的部分，工作以外的东西不是光知道就可以，还是需要去实践的。否则，就会遇到今天的情形，被个小问题，折磨了好久。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"图片处理","slug":"图片处理","permalink":"http://xiaoyu666.com/tags/图片处理/"}]},{"title":"iOS UIWebView键盘处理(转载)","slug":"iOS UIWebView键盘处理(转载)","date":"2017-04-17T13:14:52.000Z","updated":"2018-07-09T03:40:15.609Z","comments":true,"path":"2017/04/17/iOS UIWebView键盘处理(转载)/","link":"","permalink":"http://xiaoyu666.com/2017/04/17/iOS UIWebView键盘处理(转载)/","excerpt":"转载自:http://blog.csdn.net/assholeu/article/details/38714123 如果你有下面的问题，此文也许会帮到你。 键盘遮盖了UIWebView。 如何拖动UIWebView来移除键盘。 键盘出现时UIWebView里面的Content内容向上移动，以至聚焦的文本框超出了UIWebView的可视区域。 如何在键盘弹出时禁止UIWebView里面的Content向上移动。 无法在UIWebView中获取到坐标，来计算contentOffset得到想要展示的结果。","text":"转载自:http://blog.csdn.net/assholeu/article/details/38714123 如果你有下面的问题，此文也许会帮到你。 键盘遮盖了UIWebView。 如何拖动UIWebView来移除键盘。 键盘出现时UIWebView里面的Content内容向上移动，以至聚焦的文本框超出了UIWebView的可视区域。 如何在键盘弹出时禁止UIWebView里面的Content向上移动。 无法在UIWebView中获取到坐标，来计算contentOffset得到想要展示的结果。 ##一步一步说明： #####1. 唤出移除键盘只要点击UIWebView里面的html文本框控件，会自动弹出键盘。当然你需要获取键盘的信息（高度等），方法还是使用UIViewController+Notification的方式，代码如下：123456789101112131415161718192021222324252627// UIKeyboardWillShowNotification和UIKeyboardWillHideNotification为键盘弹出或移除时iOS系统post notification的名字，这里只需要定义self为这个通知的接收者即可。 // viewWillAppear:和viewWillDisappear:大家应该都很清楚，这两个方法分别在self loadView和removefromsuperview后执行。 // 特别注意：这里的object参数需要是nil,不然取不到键盘的userInfo - (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil]; &#125; - (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil]; &#125; - (void)keyboardWillShow:(NSNotification *)notification &#123; NSDictionary *userInfo = [notification userInfo]; NSValue* value = [userInfo objectForKey:UIKeyboardFrameEndUserInfoKey]; CGRect keyboardRect = [value CGRectValue]; // 这里得到了键盘的frame // 你的操作，如键盘出现，控制视图上移等 &#125; - (void)keyboardWillHide:(NSNotification *)notification &#123; // 获取info同上面的方法 // 你的操作，如键盘移除，控制视图还原等 &#125; #####2. 通过拖动UIWebView来移除键盘 12self.webView.scrollView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag; // 当拖动时移除键盘 如果是iOS7以下，请参照 6 来设置，大概思路，先添加一个private的flag表明现在键盘是否存在，当存在时，通过 6 来获取事件关闭键盘。 #####3. 键盘遮盖了UIWebView这个的解决方法可在 1 中的keyboardWillShow:里面操作，通过改变webView的origin来实现。 #####4. 键盘出现时UIWebView里面的Content内容向上移动，以至聚焦的文本框超出了UIWebView的可视区域在UIWebView中，只要键盘出现，UIWebView肯定会向上移动，至于合不合适就不好说了，如果不合适，就只用禁用自动移动。 #####5. 如何在键盘弹出时禁止UIWebView里面的Content向上移动这个方法，我也找了很久，但是还是找到了，感谢强大的网友，代码如下：1234567@interface XXX : UIViewController&lt;UIScrollViewDelegate&gt; // 添加UIScrollViewDelegate， step 1 self.webView.scrollView.delegate = self; // 注册代理， step 2 - (UIView*)viewForZoomingInScrollView:(UIScrollView*)scrollView&#123; // 实现代理方法， step 3 return nil; &#125; #####6. 如何在UIWebView中获取点击坐标众所周知，UIWebView会吃掉所有的touch事件，不然也不会有那么多人费工夫弄javascript了，但是不能设置不代表不能以另外一种方式代替，大概思路：给webView的superView添加手势，然后通过实现多手势过滤设置来实现，为什么要设置多手势过滤呢？我这里说明一下，由于UIWebView默认有自己的手势，它会拦截掉你的手势，以至 superView无法接收手势，代码如下： 12345678910111213141516171819@interface XXX : UIViewController&lt;UIGestureRecognizerDelegate&gt; // 添加UIGestureRecognizerDelegate， step 1 // 添加手势， step 2 UITapGestureRecognizer *webTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webTap:)]; webTap.numberOfTouchesRequired = 1; webTap.numberOfTapsRequired = 1; webTap.delegate = self; webTap.cancelsTouchesInView = NO; [self.view addGestureRecognizer:webTap]; // 设置过滤，ruturn YES为同时接收，至此手势可以透过webView，让你的superView也可以接收到了， step 3 -(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return YES; &#125; - (void)webTap:(UITapGestureRecognizer *)sender&#123; CGPoint tapPoint = [sender locationInView:self.webView.scrollView]; // 获取相对于webView中的坐标，如果改成self.view则获取相对于superView中的坐标， step 4 NSLog(@&quot;tapPoint x:%f y:%f&quot;,tapPoint.x,tapPoint.y); &#125; UIWebView键盘处理能想起的就只有这些了，欢迎大家补充。转载自:http://blog.csdn.net/assholeu/article/details/38714123 资料参考：感谢 http://blog.csdn.net/abel_tu/article/details/12134261","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"键盘","slug":"键盘","permalink":"http://xiaoyu666.com/tags/键盘/"}]},{"title":"在Xcode8下打印太多无用的log的解决办法","slug":"在Xcode8下打印太多无用的log的解决办法","date":"2017-03-15T03:43:53.000Z","updated":"2018-07-09T03:40:15.612Z","comments":true,"path":"2017/03/15/在Xcode8下打印太多无用的log的解决办法/","link":"","permalink":"http://xiaoyu666.com/2017/03/15/在Xcode8下打印太多无用的log的解决办法/","excerpt":"升级了Xcode8后 运行之前的项目,发现log会多出很多之前没有出现过的信息,发现是一些系统的打印的信息,很苦恼","text":"升级了Xcode8后 运行之前的项目,发现log会多出很多之前没有出现过的信息,发现是一些系统的打印的信息,很苦恼 后来发现是Xcode8的新特性 解决办法: 在scheme中添加环境变量1OS_ACTIVITY_MODE = disable 选中 target下的 Edit Scheme 在弹出的窗口中 左侧 Run 一栏的右边选中 Arguments 在 Environment Variables中添加环境变量 OS_ACTIVITY_MODE = disable 点击 Close 重新编译运行 发现 世界清净了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"}]},{"title":"更新升级10.11及以上 CocoaPods安装出问题最简单的解决方法","slug":"更新升级10.11及以上 CocoaPods安装出问题最简单的解决方法","date":"2017-02-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.612Z","comments":true,"path":"2017/02/06/更新升级10.11及以上 CocoaPods安装出问题最简单的解决方法/","link":"","permalink":"http://xiaoyu666.com/2017/02/06/更新升级10.11及以上 CocoaPods安装出问题最简单的解决方法/","excerpt":"##CocoaPods使用CocoaPods做依赖管理，使我们的工程更加自动化的、集中的、简单直观的管理第三方开源库。你不用下载开源库的源代码引入工程，不用向工程中添加Framework，不用解决开源库和开源库以及开源库和工程之间的依赖、重复问题，也不用管开源库更新等一系列问题。有了CocoaPods，你只管任性，CocoaPods会为你做好一切。","text":"##CocoaPods使用CocoaPods做依赖管理，使我们的工程更加自动化的、集中的、简单直观的管理第三方开源库。你不用下载开源库的源代码引入工程，不用向工程中添加Framework，不用解决开源库和开源库以及开源库和工程之间的依赖、重复问题，也不用管开源库更新等一系列问题。有了CocoaPods，你只管任性，CocoaPods会为你做好一切。 但是我在安装的时候发现安装cocoapods出现错误这是因为10.11把cocoapods直接干掉了 一般出现install failed的错误的时候都是国内将ruby源给墙了 原因你懂的 终端输入 123456789# sudo gem update --system//输入密码# gem sources --remove https://rubygems.org///等有反应之后再敲入以下命令//值得一提的是 淘宝源现在已经不支持http的请求了# gem sources -a https://ruby.taobao.org///验证是否替换成功可以执行# gem sources -l//确保终端中只有一个淘宝的源即可 ##安装CocoaPods 1# sudo gem install cocoapods 安装完成后执行 1# pod setup 它需要一点时间来完成，你等就是了如果安装失败 ~/.cocoapods 里面是空的，就需要重新setup命令如下： 12# pod repo remove master # pod setup 如果等待很久依旧没有出现任何提示或者提示错误可以将github: https://github.com/CocoaPods/Specs.git 上的文件替换到目录 ~/.cocoapods/repos注意 如果该目录下如果有一个master文件夹 删除并将git clone下来的文件夹改名为master 最后再执行一次命令 1# pod setup 这时候应该就成功了 ##创建和配置podXcode新建一个HelloWorld工程打开终端，进入HelloWord工程目录下：//工程的路径也可以直接拖进来123# cd /Users/mac/Desktop/HelloWorld# pod init# vim Podfile 修改类库支持的最低iOS版本 12345将# platform:ios, &quot;6.0&quot;修改成＃platform :ios, &quot;7.0&quot;//告诉CocoaPods你的工程是运行在iOS7下 最后podfile的格式应该是这样的1234567891011platform :ios, &apos;8.0&apos;source &apos;https://github.com/CocoaPods/Specs.git&apos;target &apos;HelloWorld&apos; dopod &apos;AFNetworking&apos;, :path =&gt; &apos;.&apos;pod &apos;PureLayout&apos;endtarget &apos;HelloWorldTests&apos; doend","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"macOS","slug":"macOS","permalink":"http://xiaoyu666.com/tags/macOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://xiaoyu666.com/tags/CocoaPods/"}]},{"title":"Cocoa Mac OS X下打开应用程序的OC代码","slug":"Cocoa Mac OS X下打开应用程序的OC代码","date":"2017-01-03T13:14:52.000Z","updated":"2018-07-09T03:40:15.606Z","comments":true,"path":"2017/01/03/Cocoa Mac OS X下打开应用程序的OC代码/","link":"","permalink":"http://xiaoyu666.com/2017/01/03/Cocoa Mac OS X下打开应用程序的OC代码/","excerpt":"12345NSTask *softTask = [[NSTask alloc] init];[softTask setLaunchPath:@&quot;/Applications/Xcode.app/Contents/MacOS/Xcode&quot;];[softTask launch];","text":"12345NSTask *softTask = [[NSTask alloc] init];[softTask setLaunchPath:@&quot;/Applications/Xcode.app/Contents/MacOS/Xcode&quot;];[softTask launch];","categories":[{"name":"macOS","slug":"macOS","permalink":"http://xiaoyu666.com/categories/macOS/"}],"tags":[{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"macOS","slug":"macOS","permalink":"http://xiaoyu666.com/tags/macOS/"}]},{"title":"iOS缓存清理思路整理","slug":"iOS缓存清理思路整理","date":"2016-12-30T03:25:43.000Z","updated":"2018-07-09T03:55:29.285Z","comments":true,"path":"2016/12/30/iOS缓存清理思路整理/","link":"","permalink":"http://xiaoyu666.com/2016/12/30/iOS缓存清理思路整理/","excerpt":"New info 20180709现已知在iOS 12上无法实现该功能 望悉知获取系统剩余可用的空间12345678910#import &lt;sys/mount.h&gt;+ (long long) freeDiskSpaceInBytes &#123; struct statfs buf; long long freespace = -1; if(statfs(&quot;/var&quot;, &amp;buf) &gt;= 0)&#123; freespace = (long long)(buf.f_bsize * buf.f_bfree); &#125; return freespace;&#125;","text":"New info 20180709现已知在iOS 12上无法实现该功能 望悉知获取系统剩余可用的空间12345678910#import &lt;sys/mount.h&gt;+ (long long) freeDiskSpaceInBytes &#123; struct statfs buf; long long freespace = -1; if(statfs(&quot;/var&quot;, &amp;buf) &gt;= 0)&#123; freespace = (long long)(buf.f_bsize * buf.f_bfree); &#125; return freespace;&#125; 填充剩余空间12345678910111213141516NSFileManager* fileManager = [[NSFileManager alloc ]init];NSString *apppath =[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];NSString *filePath = [apppath stringByAppendingPathComponent:@&quot;test.txt&quot;];if (![fileManager fileExistsAtPath:filePath]) &#123; [fileManager createFileAtPath:filePath contents:nil attributes:nil];&#125;NSFileHandle *outFile = [NSFileHandle fileHandleForWritingAtPath:filePath];long long truncateFile = [freeSpace longLongValue]-10*1024;if (truncateFile &gt; 0) &#123; [outFile truncateFileAtOffset:truncateFile];&#125; 删除刚刚写入的文件12345678910NSFileManager* fileManager = [[NSFileManager alloc ]init];NSString *apppath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];NSArray *files = [[NSFileManager defaultManager] subpathsAtPath:apppath];for (NSString *p in files) &#123; NSError *error; NSString *path = [apppath stringByAppendingPathComponent:p]; if ([fileManager fileExistsAtPath:path]) &#123; [fileManager removeItemAtPath:path error:&amp;error]; &#125;&#125; 原理获取了系统剩余的空间后,然后通过 truncateFileAtOffset 写入一个和剩余空间大小差不多的文件,出发iOS系统的空间清理机制,最后再删除这个文件,这样就可以达到缓存清理的目的.","categories":[{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/categories/oc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"}]},{"title":"使用easyPR来进行iOS端的车牌识别","slug":"使用easyPR来进行iOS端的车牌识别","date":"2016-10-28T08:51:33.000Z","updated":"2018-07-09T03:40:15.611Z","comments":true,"path":"2016/10/28/使用easyPR来进行iOS端的车牌识别/","link":"","permalink":"http://xiaoyu666.com/2016/10/28/使用easyPR来进行iOS端的车牌识别/","excerpt":"easyPR介绍EasyPR是一个中文的开源车牌识别系统,其目标是成为一个简单、灵活、准确的车牌识别引擎。 相比于其他的车牌识别系统，EasyPR有如下特点： 它基于openCV这个开源库。这意味着你可以获取全部源代码，并且移植到opencv支持的所有平台。 它能够识别中文。例如车牌为苏EUK722的图片，它可以准确地输出std:string类型的”苏EUK722”的结果。 它的识别率较高。图片清晰情况下，车牌检测与字符识别可以达到80%以上的精度。","text":"easyPR介绍EasyPR是一个中文的开源车牌识别系统,其目标是成为一个简单、灵活、准确的车牌识别引擎。 相比于其他的车牌识别系统，EasyPR有如下特点： 它基于openCV这个开源库。这意味着你可以获取全部源代码，并且移植到opencv支持的所有平台。 它能够识别中文。例如车牌为苏EUK722的图片，它可以准确地输出std:string类型的”苏EUK722”的结果。 它的识别率较高。图片清晰情况下，车牌检测与字符识别可以达到80%以上的精度。 最重要的是 这个是由国人开源的 easyPR github地址 后来又有一个国人 基于easyPR开发出来基于iOS版本的EasyPR-iOS EasyPR-iOS github地址 本文章也是在EasyPR-iOS基础上封装 使其易用性更高 XYPlateRecognizeUtil本人基于easyPR iOS版封装的工具库 使用block捕捉识别后的数据并传递,使用简单,高封装 XYPlateRecognizeUtil 代码XYPlateRecognizeUtil.h 12345@interface XYPlateRecognizeUtil : NSObject- (void)recognizePateWithImage:(UIImage *)image complete:(void (^)(NSArray *plateStringArray,int code))complete;@end XYPlateRecognizeUtil.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//返回值说明// plateStringArray 识别数组返回// code 识别结果错误码 -1 标识 参数错误 0 表示没有识别到车牌 1 表示识别成功//return value explaintion// plateStringArray recognize array of NSString// code message code -1 params error// 0 no plate to recognize// 1 recognize success- (void)recognizePateWithImage:(UIImage *)image complete:(void (^)(NSArray *plateStringArray,int code))complete &#123; if (!image)&#123; if (complete) complete(nil,-1); return; &#125; NSString* bundlePath=[[NSBundle mainBundle] bundlePath]; std::string mainPath=[bundlePath UTF8String]; GlobalData::mainBundle() = mainPath; pr.setLifemode(true); pr.setDebug(false); pr.setMaxPlates(4); pr.setDetectType(easypr::PR_DETECT_CMSER); //conver image to source_image //转换图片 UIImage *temp_image=[UIImageCVMatConverter scaleAndRotateImageBackCamera:image]; source_image =[UIImageCVMatConverter cvMatFromUIImage:temp_image]; //start recognize //开始识别 vector&lt;CPlate&gt; plateVec; pr.plateRecognize(source_image, plateVec); if(plateVec.size() == 0)&#123; if (complete) complete(nil,0); return; &#125; NSMutableArray *rsArratTmp = [NSMutableArray array]; size_t vecNum = plateVec.size(); for (size_t i = 0; i &lt; vecNum; i++) &#123; string name=plateVec[i].getPlateStr(); NSString *resultMessage = [NSString stringWithCString:plateVec[i].getPlateStr().c_str() encoding:NSUTF8StringEncoding]; [rsArratTmp addObject:resultMessage]; &#125; if (complete) complete([NSArray arrayWithArray:rsArratTmp],1);&#125; 另外在本项目中 使用了两种方法识别 分别是 拍照 和 选取图片在本质上,这两种方法的识别是一致,都是使用图片识别 推荐做法123456789101112131415161718//assetImage 需要被识别的图片 [[XYPlateRecognizeUtil new] recognizePateWithImage:assetImage complete:^(NSArray *plateStringArray,int code)&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSString *plateRecognizeResult; if (code != 1) &#123; [BYToastView showToastWithMessage:@&quot;没有识别到车牌号码&quot;]; return; &#125;else&#123; plateRecognizeResult = [plateStringArray componentsJoinedByString:@&quot;,&quot;]; &#125; if (!plateRecognizeResult) &#123; [BYToastView showToastWithMessage:@&quot;没有识别到车牌号码&quot;]; return; &#125; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;车牌识别&quot; message:plateRecognizeResult delegate:nil cancelButtonTitle:@&quot;返回&quot; otherButtonTitles:@&quot;完成&quot;, nil]; [alertView show]; &#125;); &#125;];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"easyPR","slug":"easyPR","permalink":"http://xiaoyu666.com/tags/easyPR/"},{"name":"智能","slug":"智能","permalink":"http://xiaoyu666.com/tags/智能/"}]},{"title":"macosx sierra安全性和隐私中找不到任何来源的解决办法","slug":"macosx-sierra安全性和隐私中找不到任何来源的解决办法","date":"2016-10-10T02:17:49.000Z","updated":"2018-07-09T03:40:15.610Z","comments":true,"path":"2016/10/10/macosx-sierra安全性和隐私中找不到任何来源的解决办法/","link":"","permalink":"http://xiaoyu666.com/2016/10/10/macosx-sierra安全性和隐私中找不到任何来源的解决办法/","excerpt":"","text":"安装完macos sierra后，如果看不到【任何来源】在终端里输入：1sudo spctl --master-disable 即可在安全选项中看到重新出现的允许任何来源选项","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://xiaoyu666.com/tags/macOS/"}]},{"title":"用keychain持久化设备的唯一识别UDID","slug":"用keychain持久化设备的唯一识别UDID","date":"2016-09-28T01:50:11.000Z","updated":"2018-07-09T03:40:15.613Z","comments":true,"path":"2016/09/28/用keychain持久化设备的唯一识别UDID/","link":"","permalink":"http://xiaoyu666.com/2016/09/28/用keychain持久化设备的唯一识别UDID/","excerpt":"在iOS中,如果想获得手机的唯一标识UDID,与硬件相关而与软件无关,在Apple的API中是不提供的 CFUUID每次调用 CFUUIDCreate 系统都会返回一个全新的唯一 ID. 如果想永久保存这个 ID，需要自己处理，可以一次获取后，存在 NSUserDefaults，Keychain，Pasteboard 等，下次再从这其中取出。","text":"在iOS中,如果想获得手机的唯一标识UDID,与硬件相关而与软件无关,在Apple的API中是不提供的 CFUUID每次调用 CFUUIDCreate 系统都会返回一个全新的唯一 ID. 如果想永久保存这个 ID，需要自己处理，可以一次获取后，存在 NSUserDefaults，Keychain，Pasteboard 等，下次再从这其中取出。 123456- (NSString *)createUUID &#123; CFUUIDRef uuid = CFUUIDCreate(NULL); CFStringRef string = CFUUIDCreateString(NULL, uuid); CFRelease(uuid); return (__bridge NSString *)string;&#125; NSUUID1NSString *uuid = [[NSUUID UUID] UUIDString]; 和 CFUUID 一样, 每次调用 NSUUID 都会获取到一个新的 UUID，需要自己保存获取到的 UUID。 Advertiser Identifier1NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; AdvertisingIdentifier 由系统保持唯一性，同一个设备上所有应用获取到 advertisingIdentifier 的都是一样的。但有两种方法可以修改这个值，重置系统（设置 -&gt; 通用 -&gt; 还原 -&gt; 抹掉所有内容和设置）或者重置广告标识符（设置 -&gt; 隐私 -&gt; 广告 -&gt; 还原广告标识符），在这两种情况下都会生成新的AdvertisingIdentifier，依然无法保证设备唯一。 Identifier for Vendor (IDFV)在Apple的API中,有一个Identifier for Vendor (IDFV)的方法 1NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; 在同一个设备上不同的 vendor 下的应用获取到的 IDFV 是不一样的，而同一个 vendor 下的不同应用获取的 IDFV 都是一样的。但如果用户删除了这个 vendor 的所有应用，再重新安装它们，IDFV 就会被重置，和之前的不一样，也不是设备唯一的。 什么是 Vendor？ 一个 Vendor 是 CFBundleIdentifier——应用标识符的前缀 举个例子， com.doubleencore.app1 和 com.doubleencore.app2 会获取到相同的 IDFV，因为它们有相通的 com.doubleencore。但 com.massivelyoverrated 和 net.doubleencore 获取到的则是不一样的 IDFV。 以上所有 ID 都不能保证设备唯一，有什么方式可以获取设备唯一 ID？ 以 IDFV 为例，为保证用户在删除应用时，取到的 IDFV 仍和之前的一样，可以借助 Keychain。使用 SAMKeychain，可以很方便地设置 keychain。 需要注意的是， keychain 在同一个苹果账号的不同设备下是同步的，需要设置query.synchronizationMode = SAMKeychainQuerySynchronizationModeNo;，不在设备间同步这个值，这样不同设备获取到的便是不同的 ID，代码如下： 1234567891011121314151617-(NSString *)getUniqueDeviceIdentifierAsString &#123; NSString *appName=[[[NSBundle mainBundle] infoDictionary] objectForKey:(NSString*)kCFBundleNameKey]; NSString *strApplicationUUID = [SAMKeychain passwordForService:appName account:@&quot;incoding&quot;]; if (strApplicationUUID == nil) &#123; strApplicationUUID = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; NSError *error = nil; SAMKeychainQuery *query = [[SAMKeychainQuery alloc] init]; query.service = appName; query.account = @&quot;incoding&quot;; query.password = strApplicationUUID; query.synchronizationMode = SAMKeychainQuerySynchronizationModeNo; [query save:&amp;error]; &#125; return strApplicationUUID;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"}]},{"title":"OC中nil/Nil/NULL/NSNull的用法和来历","slug":"OC中nil-Nil-NULL-NSNull的用法和来历","date":"2016-09-08T03:06:55.000Z","updated":"2018-07-09T03:40:15.608Z","comments":true,"path":"2016/09/08/OC中nil-Nil-NULL-NSNull的用法和来历/","link":"","permalink":"http://xiaoyu666.com/2016/09/08/OC中nil-Nil-NULL-NSNull的用法和来历/","excerpt":"学过C的同学都知道，C是用0来表示不存在的原始值。而NULL作为空指针，在指针环境中也相当于0值。其实NULL和0的值都是一样的。但是为了目的和用途及容易识别的原因，NULL用于指针和对象，0用于数值。","text":"学过C的同学都知道，C是用0来表示不存在的原始值。而NULL作为空指针，在指针环境中也相当于0值。其实NULL和0的值都是一样的。但是为了目的和用途及容易识别的原因，NULL用于指针和对象，0用于数值。 NULL要理解NULL首先得知道这么几个概念： 什么是空指针常量（null pointer constant）1An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. 值为0的整型常量表达式或者类型为void*的表达式则称为空指针常量。 什么是空指针（null pointer）1If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function. 当一个空指针常量被转换为指针类型。这个指针不指向任何实际的对象或者函数，则这个指针就称为空指针。 举个例子：char *p = 0; 此时p就是一个空指针。它不指向任何实际对象。反过来说：任何实际的对象和函数的地址都不可能是空指针。 空指针（null pointer）指向了内存的什么地方（空指针的内部实现）标准并没有对空指针指向内存中的什么地方这一个问题作出规定，也就是说用哪个具体的地址值（0x0 地址还是某一特定地址）表示空指针取决于系统的实现。常见的空指针一般指向 0 地址，即空指针的内部用全 0 来表示（zero null pointer，零空指针）；在OC中空指针指向的地址为0x0。测试代码如下： char *p = 0; printf(“%p\\n”, p); // 0x0了解了上面的几个概念后我们再来看一看NULL的定义 在头文件stddef.h中可以找到这么一句定义： 1#define NULL ((void*)0) 由定义和上面的几个概念可以看出NULL是一个值为0的空指针（本人认为），即可以这么认为：这个指针指向的地址为0x0。也就是说这个指针不指向任何对象和函数。 nilnil是Objective-C在C的表达不存在的基础上增加的。 nil是一个指向不存在的对象指针。也就相当于NULL，虽然两者语义上不同，但是技术上是相等的。刚被分配内存的NSObject的内容都被设置为0，即都为空指针。 nil有一个特别的行为就是，它虽然为零，仍然可以向他发送消息。在nil上调用方法都返回一个零值. 12NSString *name;NSLog(@&quot;%p %hhd&quot;, name, [name isEqualToString:@&quot;CoderKo1o&quot;]); // 0x0 0 Nil在苹果官方文档中，可以看到这么一段定义 12#define nil __DARWIN_NULL#define Nil __DARWIN_NULL 由此可见：Nil和nil值是一样的，那么他们有什么区别呢？ 123nil : Defines the id of a null instance.Nil : Defines the id of a null class. nil是指向0值的对象指针， Nil是指向0值的类指针，即就是为了用来区分是对象指针和类指针。 NSNull按照上面的说法，每个东西都有存在的意义，当然NSNull也有自身存在的价值。NSNull在Foundation和其他框架中被广泛地使用。 熟悉NSArray和NSDictionary之类的集合都知道，它们有一个nil值的缺陷，因为语法规定了这些集合是以nil为结束标志的。所以当你想存储一个值为空的对象。又不能使用nil（语法规定），这时候NSNull就派上用场了，NSNull可以理解为有效地对NULL或者nil值封装成一个对象。 在Foundation框架中的NSNull.h头文件中可以发现NSNUll只有一个类方法+ (NSNull *)null;返回一个表示0值的单独的对象,注意:这个对象指向的地址并不为0x0。 总结这里介绍的都是OC中用来表达没有的值，也是在学习OC过程中不可忽视的,为了更直观地表现这4个的值区别，这里列了一个表： 标志 值 含义 NULL (void *)0 C中的空指针（值为0） nil (id)0 Objective-C对象的空指针 Nil (Class)0 Objective-C类的空指针 NSNull [NSNull null] 用来表示零值的单独的对象（并非空指针）","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"}]},{"title":"[[NSNotificationCenter defaultCenter] addObserverForName:object:queue:usingBlock:]的释放问题","slug":"NSNotificationCenter-defaultCenter-addObserverForName-object-queue-usingBlock-的释放问题","date":"2016-08-31T07:47:52.000Z","updated":"2018-07-09T03:40:15.607Z","comments":true,"path":"2016/08/31/NSNotificationCenter-defaultCenter-addObserverForName-object-queue-usingBlock-的释放问题/","link":"","permalink":"http://xiaoyu666.com/2016/08/31/NSNotificationCenter-defaultCenter-addObserverForName-object-queue-usingBlock-的释放问题/","excerpt":"之前一直以为addObserverForName:object:queue:usingBlock的释放是和addObserver:selector:@selector()name:object:的释放处理逻辑是一样的 后来测试了一下 发现并不是这样","text":"之前一直以为addObserverForName:object:queue:usingBlock的释放是和addObserver:selector:@selector()name:object:的释放处理逻辑是一样的 后来测试了一下 发现并不是这样 查看文档 123- (id &lt;NSObject&gt;)addObserverForName:(nullable NSString *)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block NS_AVAILABLE(10_6, 4_0); // The return value is retained by the system, and should be held onto by the caller in // order to remove the observer with removeObserver: later, to stop observation. apple说这个方法的返回值会被system retain一下 如果要为了移除这个观察者,必须自己保留其返回值 然后removeObserver调用 所以 正确的做法是 初始化 123id&lt;NSObject&gt; notiObserver = [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationWillEnterForegroundNotification object:nil queue:nil usingBlock:^(NSNotification *note) &#123; //doSomeing&#125;]; 用全局变量将notiObserver保存 然后退出页面的时候去释放调 1if (notiObserver) [[NSNotificationCenter defaultCenter] removeObserver:notiObserver]; 这样就可以正确的释放了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"}]},{"title":"wireshark提示No interface found解决办法","slug":"wireshark提示No-interface-found解决办法","date":"2016-08-24T10:05:50.000Z","updated":"2018-07-09T03:40:15.611Z","comments":true,"path":"2016/08/24/wireshark提示No-interface-found解决办法/","link":"","permalink":"http://xiaoyu666.com/2016/08/24/wireshark提示No-interface-found解决办法/","excerpt":"","text":"wireshark提示”No interface found”解决办法 1$ sudo chmod 777 /dev/bpf* 再重启wireshark即可","categories":[{"name":"网络","slug":"网络","permalink":"http://xiaoyu666.com/categories/网络/"}],"tags":[{"name":"网络抓包","slug":"网络抓包","permalink":"http://xiaoyu666.com/tags/网络抓包/"}]},{"title":"swift字符串String常用操作总结","slug":"swift字符串String常用操作总结","date":"2016-08-15T08:16:00.000Z","updated":"2018-07-09T03:40:15.611Z","comments":true,"path":"2016/08/15/swift字符串String常用操作总结/","link":"","permalink":"http://xiaoyu666.com/2016/08/15/swift字符串String常用操作总结/","excerpt":"swift中字符串的操作 字符串的定义1234var str1=&quot;hello, mandarava.&quot; //字符串变量let str2=&quot;hello, mandarava.&quot; //字符串常量let str3=&quot;&quot; //空字符串let str4=String() //空字符串","text":"swift中字符串的操作 字符串的定义1234var str1=&quot;hello, mandarava.&quot; //字符串变量let str2=&quot;hello, mandarava.&quot; //字符串常量let str3=&quot;&quot; //空字符串let str4=String() //空字符串 字符的定义 12var char1:Character=&quot;m&quot; //字符变量let char2:Character=&quot;m&quot; //字符常量 字符串的连接 1234567891011let str1=&quot;hello, &quot;let str2=&quot;mandarava.&quot;let str3=str1+str2 //=连接str1、str2//str3=&quot;hello, mandarava.&quot;//----------------------------------------let str4=&quot;\\(str1)\\(str2)&quot; //=连接str1、str2//str4=&quot;hello, mandarava.&quot;//----------------------------------------let strArray=[&quot;apple&quot;, &quot;orange&quot;, &quot;cherry&quot;]let joinStr=&quot;,&quot;.join(strArray)//joinStr=&quot;apple,orange,cherry&quot; 字符串与字符的连接 12345678910let char1:Character=&quot;o&quot;var str1=&quot;hell&quot;let str2=str1+String(char1)//str2=&quot;hello&quot;//----------------------------------------let str3=&quot;\\(str1)\\(char1)&quot;//str3=&quot;hello&quot;//----------------------------------------str1.append(char1)//str1=&quot;hello&quot; 字符串与其它类型值的连接 1234567let xx=10let yy=10.8let str1=&quot;\\(xx)+\\(yy)=?&quot;//str1=&quot;10+10.8=?&quot;//----------------------------------------let str2=String(format: &quot;%i+%.1f=?&quot;, xx, yy)//str2=&quot;10+10.8=?&quot; 字符串枚举字符 1234567891011//Swift 1.2let str=&quot;mandarava&quot;for ch in str&#123; println(ch)&#125;//-----------------------//Swift 2.0let str=&quot;mandarava&quot;for ch in str.characters&#123; print(ch)&#125; 获取字符串中指定索引处的字符 123let str=&quot;Mandarava&quot;let chr=str[advance(str.startIndex,2)] //Swift 1.2 //chr:Character=&quot;n&quot;let chr=str[str.startIndex.advancedBy(2)] //Swift 2.0 //chr:Character=&quot;n&quot; 计算字符串长度length 1234let str=&quot;@你好啊&quot;let len1=count(str) //swift 1.2 //=4let len2=str.characters.count //swift 2.0 //=4let blen=str.lengthOfBytesUsingEncoding(NSUTF8StringEncoding) //=10 字符串比较 1234567let str1=&quot;hello,&quot;let str2=&quot;mandarava.&quot;let str3=&quot;hello,mandarava.&quot;let comp1 = str1==str2 //falselet comp2 = str1+str2 == str3 //truelet comp3 = str1 &lt; str2 //truelet comp4 = str1 != str2 //true 是否包含子串contains 123456let str1=&quot;hello,mandarava.&quot;let str2=&quot;mandarava&quot;let range=str1.rangeOfString(str2)if range != nil&#123; //包含&#125; 查找子串indexof 1234var str=&quot;hi,Mandarava.&quot;let range=str.rangeOfString(&quot;Mandarava&quot;, options: NSStringCompareOptions.allZeros) //Swift 1.2let range=str.rangeOfString(&quot;Mandarava&quot;, options: NSStringCompareOptions()) //Swift 2.0let startIndex=range?.startIndex //=3 首字母大写capitalized 123var str1=&quot;mandarava is a flower.&quot;str1.capitalizedString//str1=&quot;Mandarava Is A Flower. 转换为大写字母uppercase 123var str1=&quot;hello, mandarava.&quot;str1=str1.uppercaseString//str1=&quot;HELLO, MANDARAVA.&quot; 转换为小写字母lowercase 123var str1=&quot;HELLO, MANDARAVA.&quot;str1=str1.lowercaseString//str1=&quot;hello, mandarava.&quot; 截取字符串substring 12345678910111213let str1=&quot;hello,mandarava.&quot;let str2=str1.substringFromIndex(advance(str1.startIndex, 6)) //Swift 1.2let str2=str1.substringFromIndex(str1.startIndex.advancedBy(6)) //Swift 2.0//str2=&quot;mandarava.&quot;//----------------------------------------let str3=str1.substringToIndex(advance(str1.startIndex, 5)) //Swift 1.2let str3=str1.substringToIndex(str1.startIndex.advancedBy(5)) //Swift 2.0//str3=&quot;hello&quot;//----------------------------------------let range=Range&lt;String.Index&gt;(start: advance(str1.startIndex, 6), end: advance(str1.endIndex, -1)) //Swift 1.2let range=Range&lt;String.Index&gt;(start: str1.startIndex.advancedBy(6), end: str1.endIndex.advancedBy(-1)) //Swift 2.0let str4=str1.substringWithRange(range)//str4=&quot;mandarava&quot; 字符串修剪trim 12345678910let str1=&quot; mandarava.\\n &quot;let str2=str1.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())//str2=&quot;mandarava.&quot;//----------------------------------------let str3=str1.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceCharacterSet())//str3=&quot;mandarava.\\n&quot;//----------------------------------------let charset=NSCharacterSet(charactersInString:&quot; \\n&quot;)let str4=str1.stringByTrimmingCharactersInSet(charset)//str4=&quot;mandarava.&quot; 字符串的分解子串split 1234567var str1=&quot;boy, girl, man, woman&quot;let str1Array=str1.componentsSeparatedByString(&quot;,&quot;)//str1Array=[&quot;boy&quot;, &quot; girl&quot;, &quot; man&quot;, &quot; woman&quot;]var str2=&quot;boy,girl,man 10 20 30&quot;let charset=NSCharacterSet(charactersInString:&quot;, &quot;)let str2Array=str2.componentsSeparatedByCharactersInSet(charset)//str2Array=[&quot;boy&quot;, &quot;girl&quot;, &quot;man&quot;, &quot;10&quot;, &quot;20&quot;, &quot;30&quot;] 字符串替换replace 123456789101112131415161718192021var str1=&quot;My name is Mandarava.&quot;let subRange=Range(start: str1.startIndex, end: advance(str1.startIndex, 2)) //Swift 1.2let subRange=Range(start: str1.startIndex, end: str1.startIndex.advancedBy(2)) //Swift 2.0str1.replaceRange(subRange, with: &quot;Your&quot;)//str1=&quot;Your name is Mandarava.&quot;var str2=&quot;hello, Mandarava.&quot;str2=str2.stringByReplacingOccurrencesOfString(&quot;Mandarava&quot;, withString: &quot;你好啊&quot;)//str2=&quot;hello, 你好啊.&quot;str2=str2.stringByReplacingOccurrencesOfString(&quot;你好啊&quot;, withString: &quot;Mandarava&quot;, options: NSStringCompareOptions.CaseInsensitiveSearch, range: nil)//str2=&quot;hello, Mandarava.&quot;string转换为Int/Long/Float/Double/Bool等var str1=&quot;100&quot;var i=str1.toInt()! //Swift 1.2 //=100var i=(str1 as NSString).integerValue //Swift 2.0 //=100var i=(str1 as NSString).intValue //=100var l=(str1 as NSString).longLongValue //=100var str2=&quot;10.8&quot;var f=(str2 as NSString).floatValue //=10.8var d=(str2 as NSString).doubleValue //=10.8var str3=&quot;true&quot;var b=(str3 as NSString).boolValue //=true","categories":[{"name":"swift","slug":"swift","permalink":"http://xiaoyu666.com/categories/swift/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://xiaoyu666.com/tags/swift/"}]},{"title":"if you never try i'll never know","slug":"if-you-never-try-i-ll-never-know","date":"2016-08-11T07:37:03.000Z","updated":"2018-07-09T03:40:15.610Z","comments":true,"path":"2016/08/11/if-you-never-try-i-ll-never-know/","link":"","permalink":"http://xiaoyu666.com/2016/08/11/if-you-never-try-i-ll-never-know/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://xiaoyu666.com/categories/生活/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://xiaoyu666.com/tags/杂记/"}]},{"title":"傅园慧,说的漂亮","slug":"傅园慧-说的漂亮","date":"2016-08-11T07:33:03.000Z","updated":"2018-07-09T03:40:15.611Z","comments":true,"path":"2016/08/11/傅园慧-说的漂亮/","link":"","permalink":"http://xiaoyu666.com/2016/08/11/傅园慧-说的漂亮/","excerpt":"","text":"昨天大火的傅园慧姑娘和记者的对话我就很喜欢啊~ 傅园慧：“我有这么快！哦~~” 记者：今天这个状态有所保留吗？ 傅园慧：没有没有，我已经用了洪荒之力。 记者：…… 记者：恢复到以前的自己了么？ 傅园慧：我用了三个月去恢复，鬼知道我经历了什么。我都要死了。 记者：…… 记者：对明天决赛充满期望吗？ 傅园慧：没有哇，我已经很心满意足了。 没有对于“胜利”的过度执着，只是为自己辛苦付出而获得的进步雀跃不已。真实，自然，洒脱。这句话怎么听都够漂亮。","categories":[{"name":"生活","slug":"生活","permalink":"http://xiaoyu666.com/categories/生活/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://xiaoyu666.com/tags/杂记/"}]},{"title":"放过宁泽涛吧,奥运太难了","slug":"放过宁泽涛吧-奥运太难了","date":"2016-08-11T03:22:11.000Z","updated":"2018-07-09T03:40:15.612Z","comments":true,"path":"2016/08/11/放过宁泽涛吧-奥运太难了/","link":"","permalink":"http://xiaoyu666.com/2016/08/11/放过宁泽涛吧-奥运太难了/","excerpt":"2016 里约奥运会男子100米自由泳 小组第六，排名十二，险入半决赛，没能进入决赛。","text":"2016 里约奥运会男子100米自由泳 小组第六，排名十二，险入半决赛，没能进入决赛。 问：“是不是没发挥好？”“不是不是，就这个水平。”“是不是没适应好？”“没有，适应挺好的。”“之前胃疼，是不是不舒服？”“没，状态挺好…” 真是个耿直的boy 虽然成绩没那么耀眼，但作为进入半决赛唯一的亚洲运动员，他已经很棒了。最重要的是，他尽全力了。 可是很多人并没有想要他实至名归,比赛刚结束,新浪就出现了各种话题让我想起了2008北京奥运的刘翔 不是只有金牌,才能证明运动员的努力好像四年前2012伦敦奥运时的网友却没有今天的这么会调侃,我猜中国的社会舆论环境已经在四年内上天了 大抵是无比强大的国家荣誉感 北京之后无奥运,国家面前无老公 . 不过话说回来 每个倾尽全力的运动员,都是值得我们去为了他们而鼓掌的,除了霍顿 关于体育魅力什么的…..哦,错了,国家面前无魅力 至少我们应该理智","categories":[{"name":"生活","slug":"生活","permalink":"http://xiaoyu666.com/categories/生活/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://xiaoyu666.com/tags/杂记/"}]},{"title":"通过jenkins搭建基本iOS-app的持续交付平台","slug":"通过jenkins搭建基本iOS-app的持续交付平台","date":"2016-08-10T08:10:49.000Z","updated":"2018-07-09T03:40:15.613Z","comments":true,"path":"2016/08/10/通过jenkins搭建基本iOS-app的持续交付平台/","link":"","permalink":"http://xiaoyu666.com/2016/08/10/通过jenkins搭建基本iOS-app的持续交付平台/","excerpt":"平时我们开发完成IOS项目，需要打包给测试人员进行测试。其中的过程需要重复进行：修改配置项–编译—连接设备–运行打包–debug进设备中–然后交给等待的测试人员。现有成熟的持续集成Jenkins解决方案，并且该方案也提供了Xcode插件的支持，可以讲上述过程封装成一键解决方案。","text":"平时我们开发完成IOS项目，需要打包给测试人员进行测试。其中的过程需要重复进行：修改配置项–编译—连接设备–运行打包–debug进设备中–然后交给等待的测试人员。现有成熟的持续集成Jenkins解决方案，并且该方案也提供了Xcode插件的支持，可以讲上述过程封装成一键解决方案。 安装jenkinsjava环境准备jenkins主要依赖的java环境 所以确保电脑中java环境准确就绪支撑软件检测是否已经部署了java环境在终端输入 1$ java -version 如果出现类似于如下的字样 则标识您已经安装了java环境 1$ java version &quot;1.8.0_77&quot; 若出现如下 1$ -bash: java: command not found 则表示没有安装java环境 则需要下载java安装下载地址 (1.8版本,后续下载版本下载地址可能会有变化)java 1.8下载地址 下载安装后重复上述步骤 确保java环境成功搭建 在mac上安装jenkins安装HomeBrewjenkins依赖HomeBrew包管理,所以我们要先安装homebrew,若已安装则跳转,查看方法 1$ brew -v 若正确显示版本信息则代表安装成功安装homebrew参考网站1http://brew.sh/index_zh-cn.html 安装完成之后homebrew的源在国外,所以我们需要配置一下使之下载的快一点参考网站 http://ban.ninja在终端中输入 1$ vim ~/.bashrc 在文件最后一行 添加七牛cdn加速 1$ export HOMEBREW_BOTTLE_DOMAIN=http://7xkcej.dl1.z0.glb.clouddn.com 注:以上工作都是前期准备,因为大部分包管理(包括brew和gem)的源都在国外,所以可能下载速度会很感人 开始安装jenkins在终端输入1$ brew install jenkins 根据提示操作即可完成 大概需要不到5分钟(排除网络原因)至此:jenkins环境搭建成功 安装fastlane和fir-CLIfastlane和fir-CLI工具介绍fastlane和fir-CLI是一组工具套件,旨在实现iOS应用发布的自动化,并且提供一个良好的持续集成和部署流程,只需要一个点击或者一个命令就可以触发这个流程项目地址 fastlane(github) fir-CLI(github)shenzhen已经由一年以上没有更新了,很多功能都并不是很好用了,所以在这里我们才会安装fastlane这个工具,截止到2016年07月,fastlane工具还是可以上传到itc的 rubygems环境搭建fastlane 和 shenzhen都是ruby编写的 所以要用到gem安装查看当前的ruby版本 1$ ruby –v 代表ruby gem安装成功已经安装若没有安装rubygems 可以利用我们刚刚搭建好的brew包管理来安装gem1$ brew install ruby 注:gems其实是ruby的包管理,ruby自1.9.2以后已经安装gemsgem安装完成后我们还要修改ruby的下载源到国内参考网站ruby-china(只需要了解到该网站下的如何使用就可以了) 安装fastlane安装fastlane和fir-cli的前提是确保已经安装了xcode-tool-chain工具链,如果本地没有安装这个工具链,需要下载并安装,最简单的办法就是下载xcode 若已经安装了这个工具链(一般本地安装了xcode软件,会自动安装这个工具链的),键入如下命令1$ sudo gem install fastlane 可能需要输入密码,密码为现在mac登入账户下的登录密码 如果出现如下错误1while executing gem ... (Errno::EPERM) 键入 1$ export GEM_HOME=~/.ruby;sudo nvram boot-args=&quot;rootless=0&quot;; sudo reboot 等待重启完成后继续安装fastlane 123$ sudo gem install –n /usr/local/bin fastlane --no-ri --no-rdoc$ sudo gem install –n /usr/local/bin fir-cli --no-ri --no-rdoc 为项目初始化fastlane检查初始化查看项目code文件夹下,与xcodeproj同级目录下是否存在fastlane文件夹如果存在,可以跳过这一步,直接进行jenkins设置和环境搭建如果不存在,则要为项目初始化fastlane了 开始在终端中cd 到项目所在的文件夹下,注意:与xcodeproj文件同级)执行下面的命令 1$ fastlane init 按照提示完成输入 初始化输入appleid(该appleid 必须是对应着该项目的,而且在本地xcode中已经登录并存在与钥匙串中,并确保证书已经下载) 2.核对信息下载文件fastlane初始化结束后,会在本地生成一个名为fastlane的文件夹文件夹内包含三个文件和两个额外的文件夹 1234567891011121314151617181920AppfileDeliverfileFastfilemetadata copyright.txt primary_category.txt primary_first_sub_category.txt primary_second_sub_category.txt secondary_category.txt secondary_first_sub_category.txt secondary_second_sub_category.txt zh-Hans description.txt keywords.txt marketing_url.txt name.txt privacy_url.txt release_notes.txt support_url.txtscreenshots 这其中最重要的也是和上传相关最大关联的文件就是Fastfile和metadata文件夹中的zh-Hans文件夹中的内容其中:description.txt:描述这个app的文本文档 keywords.txt:appstore ASO(搜索关键字) marketing_url.txt :销售url name.txt: 应用名称,一般不会修改 release_notes.txt: 应用更新内容, 一般在发布版本的时候都会修改 到现在为止,所有的准备工作已经就绪,现在我们就要进入jenkins的后台去进行持续集成了.注意:fastlane的init工作一般只进行一次,如果发现存在fastlane文件夹,就不要进行这个工作了,而且这个文件会随着svn或者git一起上传上去我已经减少了不必要下载的文件和样例,只保留了两个文件 fastlane/metadata/zh-Hans/下的description.txt和release_notes.txt 因为在我看来,这个文件才是有可能经常会改动的,其他的如果想要修改,可以去 https://itunesconnect.apple.com 上登录去修改 jenkins的配置和自动打包脚本的编写启动jenkins在终端输入1$ jenkins –h 输出结果: 如果看到最后一行 Jenkins is fully up and running 则代表jenkins启动成功 在浏览器(safiri或chrome中输入地址 127.0.0.1:8080),默认jenkins的启动端口是8080 如果是第一次进入到后台,会有一些基本的配置需要来完成.按照提示来就可以了到最后一步,会让我们去安装插件,如果网络环境不好,可能会出现安装失败的情况,但是不会影响主要功能的使用 jenkins界面如果所有的配置都是在正确的,那么你会看到主界面 顾名思义: 新建 可以新建一个持续集成的任务 用户 管理用户 任务历史 可以查看持续集成的历史 系统管理 类似于系统设置,一般我们使用的较多的功能则是插件管理. Credentials 管理所有的通行证,可以是git的也可以是svn 构建view界面 构建视图view可以查看当前的构建的队列和构建任务的进行情况 搭建基于jenkins的iOS_mvs_beta项目项目目的建立该项目的目的主要是为了一键能够将iOS应用优服365能够快速方便的提供给测试人员测试,并且能够将项目一键打包成三个版本(dev,qa,prod)和分发给测试人员测试 新建任务回到主面板,点击新建 输入信息名称我们定为iOS_mvs_beta紧接着选择 构建一个只有风格的软件项目 最后点击ok 源码管理随后进入一个新的页面 找到源码管理 如果发现源码管理中没有找到你想要的 可能是没有安装对应的插件,安装插件的过程如下主界面系统管理管理插件可选插件找到 GIT plugin或者Subversion Plug-in勾选后点击最下面的按钮直接安装安装完后重启即可 可能会由于网络的原因,安装失败或根本不能访问到jenkins-ci.org提供一个subversion.hdi的国内私有下载地址,如果失效,请另行想办法下载1$ http://7xrlqi.com1.z0.glb.clouddn.com/subversion.hpi 下载完成后,上传到jenkins安转即可主界面系统管理管理插件高级上传插件选择文件后上传完成后重启 插件安装完成后,进入到项目配置页面,找到源码管理这个项目我们使用的是svn 输入svn的地址和用户名密码 添加构建命令找到 构建 这一栏点击增加构建步骤 点击 Execute shell 输入如下命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#1.usr/bin/env bashsource ~/.bash_profile#发布qa环境en=&quot;qa&quot;#打包文件存放的目录di=&quot;$&#123;HOME&#125;/jenkins/app/$&#123;JOB_NAME&#125;/$&#123;en&#125;/&quot;#打包的文件的名称name=&quot;mvs_$&#123;en&#125;-$&#123;BUILD_NUMBER&#125;-`date \\&quot;+%m月%d日%H时%M分\\&quot;`.ipa&quot;#ci环境变量路径cienvpath=&quot;$&#123;WORKSPACE&#125;/MVS/ci.env&quot;#修改ci.env的值echo &quot;&#123;\\&quot;env\\&quot;:\\&quot;$&#123;en&#125;\\&quot;&#125;&quot;&gt;$cienvpath#修改应用名称sed -i &apos;&apos; -e &quot;s/优服365/优服365_$&#123;en&#125;/g&quot; $&#123;WORKSPACE&#125;/MVS/Info.plistmkdir -p $di#打包#编译环境scheme=&quot;MVS&quot;configuration=&quot;Debug&quot;export_method=&apos;ad-hoc&apos;#指定项目地址in_path=&quot;$&#123;WORKSPACE&#125;/MVS.xcodeproj&quot;#指定输出归档文件地址archive_path=&quot;$di/archive/mvs_$&#123;en&#125;-$&#123;BUILD_NUMBER&#125;-`date \\&quot;+%m月%d日%H时%M分\\&quot;`.xcarchive&quot;#先清空前一次build在发布gym --project $&#123;in_path&#125; --scheme $&#123;scheme&#125; --clean --configuration $&#123;configuration&#125; --archive_path $&#123;archive_path&#125; --export_method $&#123;export_method&#125; --output_directory $&#123;di&#125; --output_name $&#123;name&#125;#ipa build -c Release -d $di --ipa $name#发布到蒲公英curlfileurl=&quot;@$&#123;di&#125;$&#123;name&#125;&quot;curl -F &quot;file=$&#123;curlfileurl&#125;&quot; -F &quot;uKey=5bffb7613006a47ea75bbc1b05720c16&quot; -F &quot;_api_key=8b461209f404caa7121e1374627f004b&quot; http://www.pgyer.com/apiv1/app/upload#还原名称sed -i &apos;&apos; -e &quot;s/优服365_$&#123;en&#125;/优服365/g&quot; $&#123;WORKSPACE&#125;/MVS/Info.plist#发布production环境 ali环境(测试用) 不是发布到App Storeen=&quot;prod&quot;di=&quot;$&#123;HOME&#125;/jenkins/app/$&#123;JOB_NAME&#125;/$&#123;en&#125;/&quot;name=&quot;mvs_$&#123;en&#125;-$&#123;BUILD_NUMBER&#125;-`date \\&quot;+%m月%d日%H时%M分\\&quot;`.ipa&quot;echo &quot;&#123;\\&quot;env\\&quot;:\\&quot;$&#123;en&#125;\\&quot;&#125;&quot;&gt;$cienvpathsed -i &apos;&apos; -e &quot;s/优服365/优服365_$&#123;en&#125;/g&quot; $&#123;WORKSPACE&#125;/MVS/Info.plistmkdir -p $di#打包#编译环境scheme=&quot;MVS&quot;configuration=&quot;Debug&quot;export_method=&apos;ad-hoc&apos;#指定项目地址in_path=&quot;$&#123;WORKSPACE&#125;/MVS.xcodeproj&quot;#指定输出归档文件地址archive_path=&quot;$di/archive/mvs_$&#123;en&#125;-$&#123;BUILD_NUMBER&#125;-`date \\&quot;+%m月%d日%H时%M分\\&quot;`.xcarchive&quot;#先清空前一次build在发布gym --project $&#123;in_path&#125; --scheme $&#123;scheme&#125; --clean --configuration $&#123;configuration&#125; --archive_path $&#123;archive_path&#125; --export_method $&#123;export_method&#125; --output_directory $&#123;di&#125; --output_name $&#123;name&#125;#发布到testincurlfileurl=&quot;@$&#123;di&#125;$&#123;name&#125;&quot;#上传到testincurl -F &quot;file=$&#123;curlfileurl&#125;&quot; -F &quot;user_key=d2a20900910cf09b4dd7bf039d72a7eb&quot; -F &quot;update_notify=1&quot; http://api.pre.im/api/v1/app/upload#还原名称sed -i &apos;&apos; -e &quot;s/优服365_$&#123;en&#125;/优服365/g&quot; $&#123;WORKSPACE&#125;/MVS/Info.plist#发布dev环境en=&quot;dev&quot;di=&quot;$&#123;HOME&#125;/jenkins/app/$&#123;JOB_NAME&#125;/$&#123;en&#125;/&quot;name=&quot;mvs_$&#123;en&#125;-$&#123;BUILD_NUMBER&#125;-`date \\&quot;+%m月%d日%H时%M分\\&quot;`.ipa&quot;echo &quot;&#123;\\&quot;env\\&quot;:\\&quot;$&#123;en&#125;\\&quot;&#125;&quot;&gt;$cienvpathsed -i &apos;&apos; -e &quot;s/优服365/优服365_$&#123;en&#125;/g&quot; $&#123;WORKSPACE&#125;/MVS/Info.plistmkdir -p $di#发布到fir.im 需要安装gem插件 fir-cli #gem install fir-clifir upgradefir build_ipa $&#123;WORKSPACE&#125; -o $di$name -p -T 99a2677b35d3e1b1037791a8e6c3034a 点击保存 开始第一次构建现在我们回到主面板,发现已经多了一个名为 iOS_mvs_qa 的项目,点击进入后 点击立即构建开始第一次构建 配置一键上传iTunesConnect项目目的建立该项目的目的主要是为了一键能够将iOS应用优服365能够快速方便的上传到苹果iTunesConnect的服务器,节省开发人员和上传人员的时间 建立任务如4.3.1所示,新建一个名为iOS_mvs_appstore的任务svn地址和描述都和上一个一样 编写脚本如4.3.4所示:脚本更改内容如下1234#1.usr/bin/env bash cd $&#123;WORKSPACE&#125;chmod +x upload2Appstore.sh./ upload2Appstore.sh upload2Appstore.sh 这个文件是随着svn一起down下来的附: upload2Appstore.sh 源码12345678910#1.usr/bin/env bashcienvpath=&quot;MVS/ci.env&quot;#修改ci.env的值echo &quot;&#123;\\&quot;env\\&quot;:\\&quot;production\\&quot;&#125;&quot;&gt;$cienvpathrm -f MVS.iparm -f MVS.app.dSYM.zipfastlane ios appstore","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"macOS","slug":"macOS","permalink":"http://xiaoyu666.com/tags/macOS/"}]},{"title":"解决gem安装Operation not permitted错误","slug":"解决gem安装Operation-not-permitted错误","date":"2016-08-10T06:23:11.000Z","updated":"2018-07-09T03:40:15.613Z","comments":true,"path":"2016/08/10/解决gem安装Operation-not-permitted错误/","link":"","permalink":"http://xiaoyu666.com/2016/08/10/解决gem安装Operation-not-permitted错误/","excerpt":"简单来说,这个问题应该出现在10.11 El Captain上的几率比较大原因呢 就是因为apple在El Captain引入了rootless机制 rootless一句话总结即使是root用户，将无法对以下路径有写和执行权限： /System /bin /sbin /usr (except /usr/local)","text":"简单来说,这个问题应该出现在10.11 El Captain上的几率比较大原因呢 就是因为apple在El Captain引入了rootless机制 rootless一句话总结即使是root用户，将无法对以下路径有写和执行权限： /System /bin /sbin /usr (except /usr/local) 只有Apple自身签名的软件（含命令行工具）可以。 详细说明：先简单介绍一下OS X的权限系统吧 OS X 的内核XNU,一个由Mach，BSD，IOKit混合的内核，所以它的权限管理系统类似UNIX的BSD 一个用户(user)对于一个文件有三种状态，可读(r)、可写(w)、可执行(x)，一个文件会有一个所属用户，所属用户组。还会有文件属主权限、同组用户权限、其他用户权限这三种标识符用来定义一个文件对一个用户的权限集合。 为了达到多个用户的权限管理，每个用户会在一个或者多个用户组(group)中，一个用户组可以有多个用户 root用户是一个特殊用户（超级用户），拥有对所有文件的rwx权限（可读可写可执行） UNIX系统是纯粹基于文件的，换言之你的网络读取，驱动程序，分区表什么的其实都会以文件的形式存在 再复杂点OS X 内置会有staff wheel admin这三种常见的用户组，分别介绍一下 staff : 所有创建用户都会属于这个用户组，提供最基本的对该用户目录 ~//User/())的rwx权限，其他的一般只有r或者rx权限。比如我建立一个用户叫做lizhuoli，那么我会在一个staff组里面，对/User/someone/* 有rwx权限。 admin :默认创建的所有用户也会属于这个admin用户组，在它里面的用户可以通过su或者sudo切换到root用户，只要执行以后输入这个用户的密码即可，而不需要知道root密码。 wheel :唯一只拥有一个用户root，意思是root用户的专属用户组。 OS X 10.11 加入了Rootless，默认创建的用户还是属于admin用户组，也能切换到root用户，但是加以了限制，结果是一旦你执行su 或者 sudo切换到root用户 你的这个root用户不再是真正的root用户(对所有文件有rwx) 你的这个root用户不再是真正的root用户(对所有文件有rwx) 你的这个root用户不再是真正的root用户(对所有文件有rwx) 重要的话说三遍！ 1234bash-3.2# whoamiroottouch /usr/testtouch: test: Operation not permitted 现在你虽然用 whoami 看到自己明明是root用户了，但是不能有对/System /usr等文件夹的写入权限，甚至将一些原来的所属用户组为admin的文件夹的权限全部改为了wheel（比如对/usr/local，在10.11之前都是属于当前用户:admin用户组的，启用Rootless会变成root:wheel）。 这样防止了黑客入侵，病毒修改，一些恶意软件的篡改文件权限的行为。（不过话说Homebrew — The missing package manager for OS X应该也要更新了，因为Rootless下面Homebrew的安装路径/usr/local都是root:wheel的） 当然，你也可以禁用Rootless，不过这就多了一份被恶意软件攻击的潜在威胁。建议此时打开Mac App Store 和被认可的开发者或者纯粹的Mac App Store限制。 说正事如果发生了上面的错误 告诉你就是因为rootless的原因 怎么解决 既然没有权限我换一个地方存着这个就好了 例如我要装openssl 12#macOS下$ sudo gem install –n /usr/local/bin openssl --no-ri --no-rdoc 正事说完了","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://xiaoyu666.com/tags/macOS/"},{"name":"gem","slug":"gem","permalink":"http://xiaoyu666.com/tags/gem/"}]},{"title":"中澳关系,毁于记者","slug":"中澳关系-毁于记者","date":"2016-08-10T04:31:54.000Z","updated":"2018-07-09T03:40:15.611Z","comments":true,"path":"2016/08/10/中澳关系-毁于记者/","link":"","permalink":"http://xiaoyu666.com/2016/08/10/中澳关系-毁于记者/","excerpt":"","text":"很好,这很霍顿","categories":[{"name":"生活","slug":"生活","permalink":"http://xiaoyu666.com/categories/生活/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://xiaoyu666.com/tags/杂记/"}]},{"title":"SQLite自增关键字sqlite(near AUTO_INCREMENT: syntax error)","slug":"SQLite自增关键字sqlite-near-AUTO-INCREMENT-syntax-error","date":"2016-08-08T08:05:24.000Z","updated":"2018-07-09T03:40:15.608Z","comments":true,"path":"2016/08/08/SQLite自增关键字sqlite-near-AUTO-INCREMENT-syntax-error/","link":"","permalink":"http://xiaoyu666.com/2016/08/08/SQLite自增关键字sqlite-near-AUTO-INCREMENT-syntax-error/","excerpt":"SQLite中的自增关键字：AUTO_INCREMENT、INTEGER PRIMARY KEY与AUTOINCREMENT SQLite不支持关键字AUTO_INCREMENT","text":"SQLite中的自增关键字：AUTO_INCREMENT、INTEGER PRIMARY KEY与AUTOINCREMENT SQLite不支持关键字AUTO_INCREMENT AUTO_INCREMENT不生效的问题 在SQLite中，自增字段需要使用关键字INTEGER PRIMARY KEY buffer.append(“CREATE TABLE userIntegralDetail (_id INTEGER PRIMARY KEY,”) .append(“userid char(32),”) .append(“Num char(11),”) .append(“Type char(11),”) .append(“timestamp char(13))”);db.execSQL(buffer.toString());","categories":[{"name":"sqlite","slug":"sqlite","permalink":"http://xiaoyu666.com/categories/sqlite/"}],"tags":[{"name":"sqlite","slug":"sqlite","permalink":"http://xiaoyu666.com/tags/sqlite/"},{"name":"error","slug":"error","permalink":"http://xiaoyu666.com/tags/error/"}]},{"title":"阿里云部署Docker Minecraft服务器","slug":"阿里云部署Docker-Minecraft服务器","date":"2016-08-08T07:51:36.000Z","updated":"2018-07-09T03:40:15.613Z","comments":true,"path":"2016/08/08/阿里云部署Docker-Minecraft服务器/","link":"","permalink":"http://xiaoyu666.com/2016/08/08/阿里云部署Docker-Minecraft服务器/","excerpt":"项目地址 github ##概述 因为国内网络的问题 下载minecraft服务器的时候 在aliyun上面实在是忍不了但是也很无奈","text":"项目地址 github ##概述 因为国内网络的问题 下载minecraft服务器的时候 在aliyun上面实在是忍不了但是也很无奈 所以我借鉴了国外的一位大神的项目github 修改了一下dockerfile 由于mac下并且从小受到的支持盗版的奇怪熏陶的原因 我暂时能够找到的某种意义上免费最高版本的minecraft客户端只到1.8.1 而且还找不到forge 实在是无奈 所以这个项目的version被我写死到了1.8.1 我自己翻墙下载了一些需要下载的jar包 然后在七牛云上保存 然后再替换进去 说实话 技术含量实在是低的可以 但是不得不说非常有效 hahah 下面标出我修改的地方 start.mincecraft.sh 文件是主要修改的文件 第127行 function installVanilla 方法 12345678function installVanilla &#123; SERVER=&quot;minecraft_server.$VANILLA_VERSION.jar&quot; if [ ! -e $SERVER ]; then echo &quot;Downloading $SERVER ...&quot; wget -q http://7xrlqi.com1.z0.glb.clouddn.com/minecraft_server.1.8.1.jar fi&#125; ##使用方法 ####build 1$ docker build -t minecraft . ####run 12345$ docker run -d -it -v /root/data/minecraft/data:/data -e EULA=TRUE -e VERSION=1.8.1 -e DIFFICULTY=easy -e MODE=survival -e PVP=0 -e FORCE_GAMEMODE=false -e MOTD=Waiting for xiaoqiang -e ENABLE_COMMAND_BLOCK=true -p 25565:25565 --restart=always --name mc minecraft``` ####logs $ docker logs -f mc 12####attache $ docker attache mc123456在attache中 可以作弊attache到容器中 输入 ```/help``` 查看你可以输入的作弊命令退出attache ``` ctrl+P+Q ##server.properties 属性 描述 allow-flight 允许玩家在安装添加飞行功能的mod前提下在生存模式下飞行。允许飞行可能会使作弊者更加常见，因为此设定会使他们更容易达成目的。在创造模式下本属性不会有任何作用。 false 不允许飞行。悬空超过5秒的玩家会被踢出服务器。true 允许飞行。玩家得以使用飞行MOD飞行。 allow-nether 允许玩家进入下界。false 下界传送门不会生效。true 玩家可以通过下界传送门前往下界。 difficulty 定义服务器的游戏难度（例如生物对玩家造成的伤害，饥饿与中毒对玩家的影响方式等）。0 - 和平 1 - 简单 2 - 普通 3 - 困难 enable-query 允许使用GameSpy4协议的服务器监听器。用于收集服务器信息。 enable-rcon 是否允许远程访问服务器控制台。 gamemode 定义游戏模式 0 - 生存模式 1 - 创造模式 2 - 冒险模式（仅在12w22a之后，或正式版1.3之后可用） generate-structures 定义是否在生成世界时生成结构（例如NPC村庄）false - 新生成的区块中将不包含结构。 true - 新生成的区块中将包含结构。 注：即使设为 false，地牢和下界要塞仍然会生成 generator-settings 本属性质用于自订义超平坦世界的生成。详见超平坦世界了解正确的设定及例子。 hardcore 一旦启用，玩家在死后会自动被服务器封禁（即开启极限模式）。 level-name “level-name”的值将作为世界名称及其文件夹名。你也可以把你已生成的世界存档复制过来，然后让这个值与那个文件夹的名字保持一致，服务器就可以载入该存档。部分字符，例如 ‘ （单引号）可能需要在前面加反斜杠号 \\ 才能正确应用。 level-seed 与单人游戏类似，为你的世界定义一个种子。这里有一些例子：minecraft，404，1a2b3c。 level-type 确定地图所生成的类型 DEFAULT - 标准的世界带有丘陵，河谷，海洋等 FLAT - 一个没有特色的平坦世界，适合用于建设 LARGEBIOMES - 如同预设世界，但所有生态系都更大（仅快照12w19a，或正式版1.3之后可用） AMPLIFIED - 如同预设世界，但世界生成高度提高（仅快照13w36a，或正式版1.7.2之后可用） CUSTOMIZED - 自快照14w21b以来，服务器亦支援自定义地形。使用方法是在generator-settings贴上代码。 max-build-height 玩家在游戏中能够建造的最大高度。然而地形生成算法并不会受这个值的影响。 max-players 服务器同时能容纳的最大玩家数量。但请注意在线玩家越多，对服务器造成的负担也越大，而且服务器OP也不具有在人满的情况下强行进入服务器的权力。所以请慎重设置本属性，过大的数值会使客户端显示的玩家列表崩坏。 motd 本属性值是玩家客户端的多人游戏服务器列表中显示的服务器讯息，显示于名称下方。请注意，motd 不支持彩色样式代码。 如果 motd 超过59字符，服务器列表很可能会返回“通讯错误”。 online-mode 是否允许在线验证。服务器会与 Minecraft 的账户数据库对比检查连入玩家。如果你的服务器并未与 Internet 连接，则将这个值设为 false ，然而这样的话破坏者也能够使用任意假账户登录服务器。如果 Minecraft.net 服务器下线，那么开启在线验证的服务器会因为无法验证玩家身份而拒绝所有玩家加入。通常，这个值设为 true 的服务器被称为“正版服务器”，设为 false 的被称为“离线服务器”或“盗版服务器”。 true - 启用。服务器会认为自己具有 Internet 连接，并检查每一位连入的玩家。 false - 禁用。服务器不会检查玩家。 op-permission-level 设定OP的权限等级 1 - OP可以无视重生点保护 2 - OP可以使用 /clear、/difficulty、/effect、/gamemode、/gamerule、/give 以及 /tp 指令，可以编辑指令方块 3 - OP可以使用 /ban、/deop、/kick 以及 /op 指令 4 - OP可以使用 /stop 指令 texture-pack 客户端加入服务器后是否会自动下载材质包。请在这里填入完整的材质包URL。注意：这个链接必须直接连到事实的材质包ZIP文件，而且虽然材质包可以是高清的，服务器并不会对玩家服务端进行自动高清修补。所以如果你想让大多数玩家都能够使用该材质包的话，请使用标准16x16清晰度。 pvp 是否允许PvP。玩家自己的箭也只有在允许PvP时才可能伤害到自己。注： 来源于玩家的间接伤害，例如岩浆，火，TNT等，还是会造成伤害。true - 玩家可以互相残杀。false - 玩家无法互相造成伤害。 query.port 设置监听服务器的端口号（详见enable-query）。 rcon.password 设置远程访问的密码（详见enable-rcon）。 rcon.port 设置远程访问的端口号（详见enable-rcon）。 server-ip 将服务器与一个特定IP绑定。强烈建议你留空本属性值！留空，或是填入你想让服务器绑定的IP。 server-port 改变服务器端口号。如果服务器通过路由器与外界连接的话，该端口必须也能够通过路由器。 snooper-enabled 自1.3正式版之后，一旦启用，将允许服务端定期发送统计数据到http://snoop.minecraft.net. false - 禁用数据采集 true - 启用数据采集 spawn-animals 决定动物是否可以生成。true - 动物可以生成。 false - 动物生成后会立即消失。 spawn-monsters 决定攻击型生物（怪兽）是否可以生成。true - 可以。只要满足条件的话怪物就会生成。false - 禁用。不会有任何怪物。如果difficulty = 0（和平）的话，本属性值不会有任何影响。 spawn-npcs 决定是否生成村民。true - 生成村民 false - 不会有村民。 view-distance 设置服务端传送给客户端的数据量。用每一个方向上的区块数量衡量。这个值也是客户端视野距离的上限。当视野为“远”时，实际的值为9，所以默认推荐值为 10 。 white-list 允许服务器白名单 当启用时，只有白名单上的用户才能连接服务器。白名单主要用于私人服务器，例如相识的朋友等。注 - OP会自动被视为在白名单上。所以无需再将OP加入白名单。false - 不使用白名单。true - 从 white-list.txt 文件加载白名单。 enable-command-block 当启用时地图中的命令方块可以被红石所激活注 - 只有在创造模式的OP才可以正常输入命令方块指令","categories":[{"name":"linux","slug":"linux","permalink":"http://xiaoyu666.com/categories/linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://xiaoyu666.com/tags/docker/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://xiaoyu666.com/tags/ubuntu/"},{"name":"minecraft","slug":"minecraft","permalink":"http://xiaoyu666.com/tags/minecraft/"},{"name":"阿里云","slug":"阿里云","permalink":"http://xiaoyu666.com/tags/阿里云/"}]},{"title":"iOS9使用提示框的正确实现方式(UIAlertView is deprecated)","slug":"iOS9使用提示框的正确实现方式(UIAlertView is deprecated)","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.610Z","comments":true,"path":"2016/08/06/iOS9使用提示框的正确实现方式(UIAlertView is deprecated)/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/iOS9使用提示框的正确实现方式(UIAlertView is deprecated)/","excerpt":"#前言 在从iOS8到iOS9的升级过程中，弹出提示框的方式有了很大的改变，在Xcode7 ，iOS9.0的SDK中，已经明确提示不再推荐使用UIAlertView，而只能使用UIAlertController，我们通过代码来演示一下。我通过点击一个按钮，然后弹出提示框，代码示例如下：","text":"#前言 在从iOS8到iOS9的升级过程中，弹出提示框的方式有了很大的改变，在Xcode7 ，iOS9.0的SDK中，已经明确提示不再推荐使用UIAlertView，而只能使用UIAlertController，我们通过代码来演示一下。我通过点击一个按钮，然后弹出提示框，代码示例如下： 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot; @interface ViewController () @property(strong,nonatomic) UIButton *button; @end @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; self.button = [[UIButton alloc] initWithFrame:CGRectMake(0, 100, [[UIScreen mainScreen] bounds].size.width, 20)]; [self.button setTitle:@&quot;跳转&quot; forState:UIControlStateNormal]; [self.button setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [self.view addSubview:self.button]; [self.button addTarget:self action:@selector(clickMe:) forControlEvents:UIControlEventTouchUpInside]; &#125; -(void)clickMe:(id)sender&#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;按钮被点击了&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil nil]; [alert show]; &#125; @end ##需要注意的是 ######在iOS 9.0 SDK 环境下编译上述代码时，会有下列的警告提示： “‘UIAlertView’ is deprecated:first deprecated in iOS 9.0 - UIAlertView is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleAlert instead” 意思是UIAlertView首先在iOS9中被弃用（不推荐）使用。让我们去用UIAlertController。但是运行程序，发现代码还是可以成功运行，不会出现crash。 解决这个warning，使用UIAlertController来解决这个问题。代码如下 123456789//初始化提示框； UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;按钮被点击了&quot; preferredStyle: UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; //点击按钮的响应事件； &#125;]]; //弹出提示框； [self presentViewController:alert animated:true completion:nil]; 这样，代码就不会有警告了。 程序运行后的效果同上。 其中preferredStyle这个参数还有另一个选择UIAlertControllerStyleActionSheet 选择这个枚举类型后，发现这个提示框是从底部弹出的。通过查看代码还可以发现，在提示框中的按钮响应不再需要delegate委托来实现了。直接使用addAction就可以在一个block中实现按钮点击，非常方便。 #总结可以发现这里我们呈现一个对话框使用了presentViewController这个方法，这个方法是呈现模态视图(Modal View)的方法，也就是是说，此时的提示框是一个模态视图。当我们在进行界面跳转的时候，也一般使用这个方法，此时呈现的第二个ViewController也是一个模态视图。我们可以把模态视图理解为一个浮动在原先视图上的一个临时性的视图或者界面，当在模态视图中调用dismissViewController方法时，会返回上一个界面，并销毁这个模态视图对象。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"}]},{"title":"Nginx 服务器配置 二级域名反向代理","slug":"Nginx 服务器配置 二级域名反向代理","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.607Z","comments":true,"path":"2016/08/06/Nginx 服务器配置 二级域名反向代理/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/Nginx 服务器配置 二级域名反向代理/","excerpt":"前段时间在搬瓦工买了个凤凰城的海外服务器用来翻墙用翻墙主要是使用 shadowsocks 搬瓦工服务服务管理系统openvz上面自带会有安装shodowsocks的选项,后来又想着在服务器上装个docker 把我原先的博客转移过来结果发现班瓦工linux内核版本太低不能安装docker 后来就到digtalOcean 购买了一个服务器 配置了docker环境后又碰到一个问题 我想在这个服务器上 配置git服务和ghost服务但是域名指向又存在问题于是在google后发现nginx 能很好的解决这个问题","text":"前段时间在搬瓦工买了个凤凰城的海外服务器用来翻墙用翻墙主要是使用 shadowsocks 搬瓦工服务服务管理系统openvz上面自带会有安装shodowsocks的选项,后来又想着在服务器上装个docker 把我原先的博客转移过来结果发现班瓦工linux内核版本太低不能安装docker 后来就到digtalOcean 购买了一个服务器 配置了docker环境后又碰到一个问题 我想在这个服务器上 配置git服务和ghost服务但是域名指向又存在问题于是在google后发现nginx 能很好的解决这个问题 现在将这个问题记录下来 Ubuntu安装 Nginx1$ sudo apt-get install nginx nginx 的启动和关闭123456//启动$ service nginx restart//关闭$ service nginx stop# service nginx &#123;start|stop|status|restart|reload|configtest|&#125; 因为服务器是以docker容器为基础,所以我又部署了我的另外的git服务 #####现在问题来了我想要将我的git服务绑定到二级域名git.xiaoyuyun.com 这时候nginx强大的地方就体现出来了 在/etc/nginx/sites-enabled 下新建文件 gogs用vim编辑12345678910111213141516171819202122server &#123; listen 80; server_name git.xiaoyuyun.com; # Replace with your domain root /usr/share/nginx/html; index index.html index.htm; client_max_body_size 10G; location / &#123; # 这里需要配置的是本地3000端口 # 表示是将本地3000端口反向代理到git.xiaoyuyun.com:80上面 # 这样就实现了二级域名的端口转发 # 这样之后,还需要做的就是将gogs服务配置到本地的3000端口上面 proxy_pass http://localhost:3000; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_buffering off; &#125;&#125; 下面我将介绍docker环境下面gogs的详细配置和安装再将这两者联系起来","categories":[{"name":"linux","slug":"linux","permalink":"http://xiaoyu666.com/categories/linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://xiaoyu666.com/tags/nginx/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://xiaoyu666.com/tags/ubuntu/"}]},{"title":"加班到底有什么用：压一压就出活？","slug":"加班到底有什么用：压一压就出活？","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.611Z","comments":true,"path":"2016/08/06/加班到底有什么用：压一压就出活？/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/加班到底有什么用：压一压就出活？/","excerpt":"最近在阅读温伯格的《程序员开发心理学》，这本44年前的书，其中的很多探索和观点，现在看来依然鲜活而不过时。它开创了以人为本的软件开发研究方法，是软件从业者思想启蒙的巨著，技术人生的必读经典。","text":"最近在阅读温伯格的《程序员开发心理学》，这本44年前的书，其中的很多探索和观点，现在看来依然鲜活而不过时。它开创了以人为本的软件开发研究方法，是软件从业者思想启蒙的巨著，技术人生的必读经典。 当我想讨论加班到底有什么用时，《程序开发心理学》中的一些内容如同弹幕一样从眼前浮现，启发了我。 放眼周围，到处都是加班的程序员。很多公司都加班，这是软件开发从业者的噩梦。 我应聘时被人问过“你怎么看待加班这件事”这个问题，我面试别人时也问过这个问题。有的人这么回答：“我希望能在正常的工作时间内有效的完成工作，如果情况需要，也可以适度加班”。有的人这么回答：“我就是因为受不了加班才从上家公司离职的”。 这次我不想讨论这些，我只想理一理另外一个问题：加班到底有什么用？ 尽管多数程序员对加班深恶痛绝，但加班并不是毫无作用。首先它有很多负面作用： 让程序员厌恶眼下的工作 让程序员厌恶传递加班指示的领导 让程序员厌恶所在的团队 让程序员厌恶所在的公司 让程序员无法对他需要照顾的家人交代 让程序员怀疑他所从事的这一行是否能长久干下去 降低工作效率 浪费公司资源（水、电、办公用品等） 耽误正常工作 造成“正常工作时间瞎胡混，加班赶白天落下的进度”这种工作方式 有效降低程序员的工作积极性 交付低质量和埋了各种雷的产品 其次，实际上，不管对个人还是对公司，它也可能多多少少有一些“积极”作用： 造成一种假象，让领导觉得大家都在忙，心里踏实 造成团队凝聚力、执行力高的假象 不能按时交付时，向老板和客户展示努力的过程，给个不是交代的交代 对于依赖工时的任务，是有效的 有助于那些不推不动的人产出点东西-对于海绵一样的新手或极度渴望学习的程序员，可以学到一些知识、技能、经验 磨练程序员的心性，让程序员变得敷衍或者淡然影响绩效 从另一个维度来说，加班有没有作用，就看这次加班，这个人是接纳的，还是拒绝的。假如阿猿乐意通过加班来完成某些事情，那自然是有效果的，因为这样的加班有明确的目的性，阿猿是自发地奔向它的目的。此时的加班，不觉其苦，反倒有愉悦之感，只恨时间飞逝不能多做停留。 《程序开发心理学》在“积极性、培训及经验”一章里有这么一段话： 过于努力地去查找错误，与根本不去查找同样坏，甚至还要更坏。实际上，往往要等到程序员已经决定放弃从而不再承受压力之后，许多程序错误才能被排除掉。给程序员施加高压，以期他们能够很快地排除某个程序错误，这种做法已经被证明是最差的策略——尽管截至目前，这仍是最常被采用的策略。 44年过去了，温伯格的话还没过时，我们还天天在用这种“压一压就出活”的策略，想想真是令人唏嘘。","categories":[{"name":"生活","slug":"生活","permalink":"http://xiaoyu666.com/categories/生活/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://xiaoyu666.com/tags/杂记/"}]},{"title":"(转载)OC-如何让图片长的好看（contentMode）","slug":"(转载)OC-如何让图片长的好看（contentMode）","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.606Z","comments":true,"path":"2016/08/06/(转载)OC-如何让图片长的好看（contentMode）/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/(转载)OC-如何让图片长的好看（contentMode）/","excerpt":"转载至CSDN http://blog.csdn.net/yi_zz32/article/details/50381762 我们在开发中，经常要在view，tableView，等显示图片，比如我们发微博（带有图片的），那么我们常常要考虑如何处理这些图片，是否拉伸，拉伸到什么样的效果等等，常常是需要考虑的问题。","text":"转载至CSDN http://blog.csdn.net/yi_zz32/article/details/50381762 我们在开发中，经常要在view，tableView，等显示图片，比如我们发微博（带有图片的），那么我们常常要考虑如何处理这些图片，是否拉伸，拉伸到什么样的效果等等，常常是需要考虑的问题。其实主要的还是要理解UIImageView的ContentMode的这些参数，这些参数一般就能满分我们的开发需求 123456789101112UIViewContentModeScaleToFill,UIViewContentModeScaleAspectFit, // contents scaled to fit with fixed aspect. remainder is transparentUIViewContentModeScaleAspectFill, // contents scaled to fill with fixed aspect. some portion of content may be clipped. UIViewContentModeRedraw, // redraw on bounds change (calls -setNeedsDisplay) UIViewContentModeCenter, // contents remain same size. positioned adjusted. UIViewContentModeTop,UIViewContentModeBottom,UIViewContentModeLeft,UIViewContentModeRight,UIViewContentModeTopLeft,UIViewContentModeTopRight,UIViewContentModeBottomLeft,UIViewContentModeBottomRight, 那我们接下来，就来说明一下，这些值都代表什么意思 12345UIViewContentModeScaleToFill：图片拉伸至填充这个UIImageView(图片可能变形)UIViewContentModeScaleAspectFit : 图片拉伸至完全显示在UIImageView里面为止（图片不会变形）UIViewContentModeScaleAspectFill ： 图片拉伸至 图片的宽度等于UIImageView的宽度 或者 图片的高度等于UIImageView的高度为止，然后将图片居中显示UIViewContentModeRedraw ： 调用了setNeedsDisplay方法时，就会将图片重新渲染UIViewContentModeCenter：居中显示","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"图片处理","slug":"图片处理","permalink":"http://xiaoyu666.com/tags/图片处理/"}]},{"title":"UITableView 空数据或者错误时候的提示 empty Table","slug":"UITableView 空数据或者错误时候的提示 empty Table","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.608Z","comments":true,"path":"2016/08/06/UITableView 空数据或者错误时候的提示 empty Table/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/UITableView 空数据或者错误时候的提示 empty Table/","excerpt":"https://github.com/dzenbot/DZNEmptyDataSet DZNEmptyDataSet是一个下拉式的UITableView/UICollectionView父类，在没有内容要显示时使用Empty DataSet模式。","text":"https://github.com/dzenbot/DZNEmptyDataSet DZNEmptyDataSet是一个下拉式的UITableView/UICollectionView父类，在没有内容要显示时使用Empty DataSet模式。 大多数应用程序都会显示内容列表（datasets），但是某些情况下可能会是空的，尤其是新用户的账户信息。一旦产生错误或bug，空白屏幕会使用户困惑，不知道要做什么，所以Empty DataSet模式应该能够给用户提示相关信息。 Empty DataSet模式的好处：避免白屏，告诉用户屏幕为何为空；提示用户下一步的操作；避免其它中断机制，比如显示错误提醒；保持连续性，改善用户体验；展示品牌标示。 功能：可自定义背景颜色和视图以及垂直和水平对齐，多种布局和外观，支持点击手势和自动旋转，兼容UITableView和UICollectionView以及Storyboard。 你可以不使用UITableView或UICollectionView设计该库，可以使用UITableViewController或UICollectionViewController。只要符合DZNEmptyDataSetSource＆DZNEmptyDataSetDelegate，你就可以完全自定义你的应用程序的Empty DataSet的内容和外观。 代码下载地址：https://github.com/dzenbot/DZNEmptyDataSet 更多详细内容可参考：https://www.cocoacontrols.com/controls/dznemptydataset","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS,oc,UITableView","slug":"iOS-oc-UITableView","permalink":"http://xiaoyu666.com/tags/iOS-oc-UITableView/"}]},{"title":"UITableViewHeaderFooterView 的使用和透明背景色的设置","slug":"UITableViewHeaderFooterView 的使用和透明背景色的设置","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.608Z","comments":true,"path":"2016/08/06/UITableViewHeaderFooterView 的使用和透明背景色的设置/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/UITableViewHeaderFooterView 的使用和透明背景色的设置/","excerpt":"####环境 iOS 9.3 下测试 2016-06-16 我们知道UITableView有代理方法设置每个section的headerview和footerview 为了减少UITableView的内存开销","text":"####环境 iOS 9.3 下测试 2016-06-16 我们知道UITableView有代理方法设置每个section的headerview和footerview 为了减少UITableView的内存开销 Apple引入了UITableViewHeaderFooterView这个类 这个类是在iOS 6 的时候加入 和UITableViewCell这个类一样 这个类由reuseIdentifier 这个概念所以初始化方法也和UITableViewCell类似了 直接上代码 ###Apple 关于UITableViewHeaderFooterView的定义123456789101112131415161718192021222324252627#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIView.h&gt;#import &lt;UIKit/UITableView.h&gt;// Either the header or footer for a sectionNS_ASSUME_NONNULL_BEGINNS_CLASS_AVAILABLE_IOS(6_0) @interface UITableViewHeaderFooterView : UIView- (instancetype)initWithReuseIdentifier:(nullable NSString *)reuseIdentifier NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;@property (nonatomic, strong, null_resettable) UIColor *tintColor;@property (nonatomic, readonly, strong, nullable) UILabel *textLabel;@property (nonatomic, readonly, strong, nullable) UILabel *detailTextLabel; // only supported for headers in grouped style@property (nonatomic, readonly, strong) UIView *contentView;@property (nonatomic, strong, nullable) UIView *backgroundView;@property (nonatomic, readonly, copy, nullable) NSString *reuseIdentifier;- (void)prepareForReuse; // if the view is reusable (has a reuse identifier), this is called just before the view is returned from the table view method dequeueReusableHeaderFooterViewWithIdentifier:. If you override, you MUST call super.@endNS_ASSUME_NONNULL_END ###实际应用1234567891011121314151617181920212223242526272829303132333435363738394041- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section&#123; if (tableView.tag == 100) &#123; static NSString *tableViewHeaderViewIdentifier = @&quot;tableViewHeaderViewIdentifier&quot;; UITableViewHeaderFooterView *headView = [tableView tableViewHeaderViewIdentifier]; if (!headView) &#123; headView = [[UITableViewHeaderFooterView alloc] initWithReuseIdentifier:tableViewHeaderViewIdentifier]; &#125; UILabel *tableHeaderLabel = [headView viewWithTag:10001]; if (!tableHeaderLabel) &#123; tableHeaderLabel = [[UILabel alloc]init]; tableHeaderLabel.tag = 10001; tableHeaderLabel.frame = (CGRect)&#123;20,0,WIDTH(tableView)-40,40&#125;; tableHeaderLabel.font = Font(inchesForValue(16, 18)); tableHeaderLabel.textColor = RGBColor(26, 161, 230); tableHeaderLabel.textAlignment = NSTextAlignmentCenter; [headView.contentView addSubview:tableHeaderLabel]; &#125; tableHeaderLabel.text = @&quot;title&quot;; UIView *lineView = [headView viewWithTag:10002]; if (!lineView) &#123; lineView = [[UIView alloc] init]; lineView.tag = 10002; lineView.frame = (CGRect)&#123;0,0,WIDTH(tableView),0.5&#125;; lineView.backgroundColor = RGBAColor(118, 134, 147, 0.2); [headView addSubview:lineView]; &#125; UIView *bottomLineView = [headView viewWithTag:10003]; if (!bottomLineView) &#123; bottomLineView = [[UIView alloc] init]; bottomLineView.tag = 10003; bottomLineView.frame = (CGRect)&#123;0,HEIGHT(tableHeaderLabel)-0.5,WIDTH(tableView),0.5&#125;; bottomLineView.backgroundColor = RGBAColor(118, 134, 147, 0.2); [headView addSubview:bottomLineView]; &#125; return headView; &#125; return nil;&#125; 这样设置之后 会发现apple给的默认的UITableViewHeaderFooterView的背景颜色是灰色如果我们要改成透明颜色 这时候就要加入这个代理了 12345- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section &#123; if ([view isMemberOfClass:[UITableViewHeaderFooterView class]]) &#123; ((UITableViewHeaderFooterView *)view).backgroundView.backgroundColor = [UIColor clearColor]; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS,oc,UITableView","slug":"iOS-oc-UITableView","permalink":"http://xiaoyu666.com/tags/iOS-oc-UITableView/"}]},{"title":"UITableView的Header不悬浮不吸附的方法","slug":"UITableView的Header不悬浮不吸附的方法","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.609Z","comments":true,"path":"2016/08/06/UITableView的Header不悬浮不吸附的方法/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/UITableView的Header不悬浮不吸附的方法/","excerpt":"当 UITableView 的 style 属性设置为 Plain 时，这个tableview的section header在滚动时会默认悬停在界面顶端。","text":"当 UITableView 的 style 属性设置为 Plain 时，这个tableview的section header在滚动时会默认悬停在界面顶端。 1234567891011121314151617181920212223242526272829303132333435#pragma mark - UIScrollViewDelegate//使用这个方法主要是 让tableview的section不要停留在界面上- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGFloat sectionHeaderHeight = 30; if (scrollView.contentOffset.y&lt;=sectionHeaderHeight&amp;&amp;scrollView.contentOffset.y&gt;=0) &#123; scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); &#125; else if (scrollView.contentOffset.y&gt;=sectionHeaderHeight) &#123; scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); &#125;&#125;- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; CGFloat sectionHeaderHeight = 30; if (scrollView.contentInset.top &lt; 0 &amp;&amp; scrollView.contentInset.top &lt; fabs(sectionHeaderHeight) &amp;&amp; scrollView.contentOffset.y &lt;= sectionHeaderHeight+0.5) &#123; [UIView animateWithDuration:0.3f animations:^&#123; [scrollView setContentOffset:(CGPoint)&#123;0,0&#125;]; scrollView.contentInset = UIEdgeInsetsMake(0, 0, 0, 0); &#125;]; &#125;&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; CGFloat sectionHeaderHeight = 30; if (scrollView.contentInset.top &lt; 0 &amp;&amp; scrollView.contentInset.top &lt; fabs(sectionHeaderHeight) &amp;&amp; scrollView.contentOffset.y &lt;= sectionHeaderHeight+0.5) &#123; [UIView animateWithDuration:0.3f animations:^&#123; [scrollView setContentOffset:(CGPoint)&#123;0,0&#125;]; scrollView.contentInset = UIEdgeInsetsMake(0, 0, 0, 0); &#125;]; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"UITableView","slug":"UITableView","permalink":"http://xiaoyu666.com/tags/UITableView/"}]},{"title":"OC 通过代码获取 LaunchImage","slug":"OC 通过代码获取 LaunchImage","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.607Z","comments":true,"path":"2016/08/06/OC 通过代码获取 LaunchImage/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/OC 通过代码获取 LaunchImage/","excerpt":"","text":"1234567891011 CGSize viewSize =self.view.bounds.size; NSString *viewOrientation = @&quot;Portrait&quot;;//横屏请设置成 @&quot;Landscape&quot; NSString *launchImage = nil; NSArray *imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;]; for(NSDictionary *dict in imagesDict) &#123; CGSize imageSize =CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]); if(CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]]) &#123; launchImage = dict[@&quot;UILaunchImageName&quot;]; &#125; &#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"LaunchImage","slug":"LaunchImage","permalink":"http://xiaoyu666.com/tags/LaunchImage/"}]},{"title":"禁用UIWebView的长按手势","slug":"禁用UIWebView的长按手势","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.613Z","comments":true,"path":"2016/08/06/禁用UIWebView的长按手势/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/禁用UIWebView的长按手势/","excerpt":"当webview显示html页面的时候 本身会提供一些原生的交互行为 长按文字选中就是其中的一种 这时候 如果要禁用这个效果","text":"当webview显示html页面的时候 本身会提供一些原生的交互行为 长按文字选中就是其中的一种 这时候 如果要禁用这个效果 在webview的delegate中加入如下的代码 123456- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; NSLog(@&quot;webViewDidFinishLoad&quot;); [webView stringByEvaluatingJavaScriptFromString:@&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;;&quot;]; [webView stringByEvaluatingJavaScriptFromString:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&quot;];&#125; 当然 更好的方法是在html的原始文件中 加入如下的代码 123456 &lt;script type=&quot;text/JavaScript&quot;&gt; window.onload=function(&#123; document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&#125;; &lt;/script&gt; 这样子不管谁调用都没有这个手势了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/tags/iOS/"},{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"}]},{"title":"XYW8AnimationIndicatorView","slug":"XYW8AnimationIndicatorView","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.609Z","comments":true,"path":"2016/08/06/XYW8AnimationIndicatorView/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/XYW8AnimationIndicatorView/","excerpt":"项目地址 Github XYW8AnimationIndicatorViewA Windows startup indicatorviewStyle for iOS with Objective-C delegate support iOS 仿照windows10 开机动画做的一个indicator view视图 动画效果体验极佳","text":"项目地址 Github XYW8AnimationIndicatorViewA Windows startup indicatorviewStyle for iOS with Objective-C delegate support iOS 仿照windows10 开机动画做的一个indicator view视图 动画效果体验极佳 #Short Cut #English ##How to Use ###alloc and start animation12345678XYW8IndicatorView *animationView = [[XYW8IndicatorView alloc] init];animationView.backgroundColor = [UIColor colorWithWhite:0 alpha:0.5];animationView.frame = (CGRect)&#123;0,0,self.view.frame.size.width,self.view.frame.size.height&#125;;animationView.dotColor = [UIColor redColor];animationView.delegate = self;[self.view addSubview:animationView];[animationView startAnimating]; ###stop the animation 123- (void)stopAnimating:(BOOL)animated;- (void)stopAnimating:(BOOL)animated afterDelay:(NSTimeInterval)delay; ###propertys 123456789101112@interface XYW8IndicatorView : UIView//set the animating dot backgroundcolor default set to [UIColor grayColor] if nil also set to [UIColor grayColor]@property (nonatomic,strong) UIColor *dotColor;//set the loadingLabel default set the text to @&quot;loading&quot;@property (nonatomic,strong) UILabel *loadingLabel;@property (nonatomic,assign) id&lt;XYW8IndicatorViewDelegate&gt; delegate;//current animating state@property (nonatomic,readonly,getter=isAnimating) BOOL animating; ##Full Delegate Support12345678910111213141516@protocol XYW8IndicatorViewDelegate &lt;NSObject&gt;@optional//called when clicked background view in here you can cut off background network requset- (void)indicatorViewDidTapBakground:(XYW8IndicatorView *)indicatorView;//called when the animation will/did start- (void)indicatorViewWillStartAnimating:(XYW8IndicatorView *)indicatorView;- (void)indicatorViewDidStartAnimating:(XYW8IndicatorView *)indicatorView;//called when the animation will/did end- (void)indicatorView:(XYW8IndicatorView *)indicatorView willEndAnimating:(BOOL)animted;- (void)indicatorView:(XYW8IndicatorView *)indicatorView didEndAnimating:(BOOL)animted;@end ##Questionif any question or bug email me with xiaoamani@qq.com China #中文 ##使用说明 ###初始化和开始动画12345678XYW8IndicatorView *animationView = [[XYW8IndicatorView alloc] init];animationView.backgroundColor = [UIColor colorWithWhite:0 alpha:0.5];animationView.frame = (CGRect)&#123;0,0,self.view.frame.size.width,self.view.frame.size.height&#125;;animationView.dotColor = [UIColor redColor];animationView.delegate = self;[self.view addSubview:animationView];[animationView startAnimating]; ###停止动画 123- (void)stopAnimating:(BOOL)animated;- (void)stopAnimating:(BOOL)animated afterDelay:(NSTimeInterval)delay; ###propertys 123456789101112131415@interface XYW8IndicatorView : UIView//set the animating dot backgroundcolor default or nil set to [UIColor grayColor]//设置要进行动画的点的背景颜色 如果传入nil或不设置该参数 默认设置成[UIColor grayColor]@property (nonatomic,strong) UIColor *dotColor;//set the loadingLabel default set the text to @&quot;loading&quot;//设置动画过程中的loadingLabel的属性 默认文字为loading@property (nonatomic,strong) UILabel *loadingLabel;@property (nonatomic,assign) id&lt;XYW8IndicatorViewDelegate&gt; delegate;//current animating state//现在是否处于动画中@property (nonatomic,readonly,getter=isAnimating) BOOL animating; ##支持delegate12345678910111213141516171819@protocol XYW8IndicatorViewDelegate &lt;NSObject&gt;@optional//call when clicked background view in here you can cut off background network requset//当tap背景时,该函数会被触发,在这儿你可以取消后台的网络请求去刷新界面- (void)indicatorViewDidTapBakground:(XYW8IndicatorView *)indicatorView;//call when the animation will/did start//当动画 将要/已经 开始时的回调- (void)indicatorViewWillStartAnimating:(XYW8IndicatorView *)indicatorView;- (void)indicatorViewDidStartAnimating:(XYW8IndicatorView *)indicatorView;//call when the animation will/did end//当动画 将要/已经 结束时的回调- (void)indicatorView:(XYW8IndicatorView *)indicatorView willEndAnimating:(BOOL)animted;- (void)indicatorView:(XYW8IndicatorView *)indicatorView didEndAnimating:(BOOL)animted;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"iOS,oc,XYW8AnimationIndicatorView","slug":"iOS-oc-XYW8AnimationIndicatorView","permalink":"http://xiaoyu666.com/tags/iOS-oc-XYW8AnimationIndicatorView/"}]},{"title":"UIScrollerView-XYRefresh","slug":"UIScrollerView-XYRefresh","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.608Z","comments":true,"path":"2016/08/06/UIScrollerView-XYRefresh/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/UIScrollerView-XYRefresh/","excerpt":"","text":"UIScrollerView-XYRefresh UIScrollerView 扩展 用于上拉刷新和下拉刷新 刷新动作被触发的时候 block捕捉 一个非常简便的scrollview上拉刷新和下拉刷新的实现 项目地址 Github","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"ios","slug":"ios","permalink":"http://xiaoyu666.com/tags/ios/"},{"name":"UIScrollerView-XYRefresh","slug":"UIScrollerView-XYRefresh","permalink":"http://xiaoyu666.com/tags/UIScrollerView-XYRefresh/"}]},{"title":"OC-Block使用和分析","slug":"OC-Block使用和分析","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.607Z","comments":true,"path":"2016/08/06/OC-Block使用和分析/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/OC-Block使用和分析/","excerpt":"#block使用 ##第一部分 ###定义和使用Block， 1234567891011121314151617void (^printBlock)() = ^()&#123; printf(&quot;no number&quot;);&#125;;printBlock();printBlock(9);int mutiplier = 7;//（3）定义名为myBlock的代码块，返回值类型为intint (^myBlock)(int) = ^(int num)&#123; return num*mutiplier;&#125;//使用定义的myBlockint newMutiplier = myBlock(3);printf(&quot;newMutiplier is %d&quot;,myBlock(3));","text":"#block使用 ##第一部分 ###定义和使用Block， 1234567891011121314151617void (^printBlock)() = ^()&#123; printf(&quot;no number&quot;);&#125;;printBlock();printBlock(9);int mutiplier = 7;//（3）定义名为myBlock的代码块，返回值类型为intint (^myBlock)(int) = ^(int num)&#123; return num*mutiplier;&#125;//使用定义的myBlockint newMutiplier = myBlock(3);printf(&quot;newMutiplier is %d&quot;,myBlock(3)); ###定义在-viewDidLoad方法外部 1234//（2）定义一个有参数，没有返回值的Blockvoid (^printNumBlock)(int) = ^(int num)&#123; printf(&quot;int number is %d&quot;,num);&#125;; 定义Block变量，就相当于定义了一个函数。但是区别也很明显，因为函数肯定是在-viewDidLoad方法外面定义，而Block变量定义在了viewDidLoad方法内部。当然，我们也可以把Block定义在-viewDidLoad方法外部，例如上面的代码块printNumBlock的定义，就在-viewDidLoad外面。 再来看看上面代码运行的顺序问题，以第（3）个myBlock距离来说，在定义的地方，并不会执行Block{}内部的代码，而在myBlock(3)调用之后才会执行其中的代码，这跟函数的理解其实差不多，就是只要在调用Block（函数）的时候才会执行Block体内（函数体内）的代码。所以上面的简单代码示例，我可以作出如下的结论， ######（1）在类中，定义一个Block变量，就像定义一个函数； ######（2）Block可以定义在方法内部，也可以定义在方法外部； ######（3）只有调用Block时候，才会执行其{}体内的代码； ######（PS：关于第（2）条，定义在方法外部的Block，其实就是文件级别的全局变量） 那么在类中定义一个Block，特别是在-viewDidLoad方法体内定义一个Block到底有什么意义呢？我表示这时候只把它当做私有函数就可以了。我之前说过，Block其实就相当于代理，那么这时候我该怎样将其与代理类比以了解呢。这时候我可以这样说：本类中的Block就相当于类自己服从某个协议，然后让自己代理自己去做某个事情。 ##第二部分 ###__block关键字的使用 在Block的{}体内，是不可以对外面的变量进行更改的，比如下面的语句， 123456int x = 100;void (^sumXAndYBlock)(int) = ^(int y)&#123;x = x+y;printf(&quot;new x value is %d&quot;,x);&#125;;sumXAndYBlock(50); 这段代码有什么问题呢，Xcode会提示x变量错误信息：Variable is not assigning (missing block type)，这时候给int x = 100;语句前面加上block关键字即可，如下， 1__block int x = 100; 这样在Block的{}体内，就可以修改外部变量了。 ##第三部分：Block作为property属性实现页面之间传值 第二个页面总的代码如下 1234567891011@interface NextViewController : UIViewController@property (nonatomic, copy) void (^NextViewControllerBlock)(NSString *tfText);@end//NextViewContorller.m 文件- (IBAction)popBtnClicked:(id)sender &#123; if (self.NextViewControllerBlock) &#123; self.NextViewControllerBlock(self.inputTF.text); &#125; [self.navigationController popViewControllerAnimated:YES];&#125; 第一个页面总的代码如下 123456789101112- (IBAction)btnClicked:(id)sender &#123; NextViewController *nextVC = [[NextViewController alloc] initWithNibName:@&quot;NextViewController&quot; bundle:nil]; nextVC.NextViewControllerBlock = ^(NSString *tfText)&#123; [self resetLabel:tfText]; &#125;; [self.navigationController pushViewController:nextVC animated:YES];&#125;#pragma mark - NextViewControllerBlock method- (void)resetLabel:(NSString *)textStr&#123; self.nextVCInfoLabel.text = textStr;&#125; #block使用分析 就像delegate的简化版代理设计模式对于iOS开发的人来说肯定很熟悉了，代理delegate就是委托另一个对象来帮忙完成一件事情，为什么要委托别人来做呢，这其实是MVC设计模式中的模块分工问题，例如View对象它只负责显示界面，而不需要进行数据的管理，数据的管理和逻辑是Controller的责任，所以此时View就应该将这个功能委托给Controller去实现，当然你作为码农强行让View处理数据逻辑的任务，也不是不行，只是这就违背了MVC设计模式，项目小还好，随着功能的扩展，我们就会发现越写越难写；还有一种情况，就是这件事情做不到，只能委托给其他对象来做了，下面的例子中我会说明这种情况。 ##实际情景使用 下面的代码我想实现一个简单的功能，场景描述如下：TableView上面有多个CustomTableViewCell，cell上面显示的是文字信息和一个详情Button，点击button以后push到一个新的页面。为什么说这个场景用到了代理delegate？因为button是在自定义的CustomTableViewCell上面，而cell没有能力实现push的功能，因为push到新页面的代码是这样的， 1[self.navigationController pushViewController]; 所以这时候CustomTableViewCell就要委托它所在的Controller去做这件事情了。 ###为了方便比较 先使用delegate的方式实现按照我的编码习惯，我喜欢把委托的协议写在提出委托申请的类的头文件里面，现在的场景中是CustomTableViewCell提出了委托申请，下面是简单的代码 12345678910111213141516@protocol CustomCellDelegate &lt;NSObject&gt;- (void)pushToNewPage;@end@interface CustomTableViewCell : UITableViewCell@property (nonatomic, assign) id&lt;CustomCellDelegate&gt; delegate;@property (nonatomic, strong) UILabel *text1Label;@property (nonatomic, strong) UIButton *detailBtn;@end 上面的代码在CustomTableViewCell.h中定义了一个协议CustomCellDelegate，它有一个需要实现的pushToNewPage方法，然后还要写一个属性修饰符为assign、名为delegate的property，之所以使用assign是因为这涉及到内存管理的东西，以后的博客中我会专门说明原因。 接下来在CustomTableViewCell.m中编写Button点击代码， [self.detailBtn addTarget:self action:@selector(btnClicked:) forControlEvents:UIControlEventTouchUpInside]; 对应的btnClicked方法如下 12345- (void)btnClicked:(UIButton *)btn &#123; if (self.delegate &amp;&amp; [self.delegaterespondsToSelector:@selector(pushToNewPage)]) &#123; [self.delegate pushToNewPage]; &#125;&#125; 上面代码中的判断条件最好是写上，因为这是判断self.delegate是否为空，以及实现CustomCellDelegate协议的Controller是否也实现了其中的pushToNewPage方法。 接下来就是受到委托申请的类，这里是对应CustomTableViewCell所在的ViewController，它首先要实现CustomCellDelegate协议，然后要实现其中的pushToNewPage方法，还有一点不能忘记的就是要设置CustomTableViewCell对象cell的delegate等于self，很多情况下可能忘了写cell.delegate = self;导致遇到问题不知云里雾里。下面的关键代码都是在ViewController.m中， 首先是服从CumtomCellDelegate协议，这个大家肯定都知道，就像很多系统的协议，例如UIAlertViewDelegate、UITextFieldDelegate、UITableViewDelegate、UITableViewDatasource一样。 12345678910111213141516171819202122232425262728@interface ViewController ()&lt;CustomCellDelegate&gt;@property (nonatomic, strong) NSArray *textArray;@end//然后是实现CustomCellDelegate协议中的pushToNewPage方法，- (void)pushToNewPage &#123; DetailViewController*detailVC = [[DetailViewController alloc] init]; [self.navigationController pushViewController:detailVC animated:YES];&#125;//还有一个步骤最容易被忘记，就是设置CumtomTableViewCell对象cell的delegate，如下代码，- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *simpleIdentify = @&quot;CustomCellIdentify&quot;; CustomTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:simpleIdentify]; if (cell == nil) &#123; cell = [[CustomTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:simpleIdentify]; &#125; //下面代码很关键 cell.delegate = self; cell.text1Label.text = [self.textArray objectAtIndex:indexPath.row]; return cell;&#125; 通过cell.delegate = self;确保了CustomTableViewCell.m的判断语句if(self.delegate &amp;&amp; …){}中得self.delegate不为空，此时的self.delegate其实就是ViewController，cell对象委托了ViewController实现pushToNewPage方法。这个简单的场景描述了使用代理的一种情况，就是CustomTableViewCell没有能力实现pushViewController的功能，所以委托ViewController来实现。 ###下面使用block的方式实现 Block是一个C语言的特性，它就是C语言的函数指针，在使用中最多的就是进行函数回调或者事件传递，比如发送数据到服务器，等待服务器反馈是成功还是失败，此时block就派上用场了，这个功能的实现也可用使用代理，这么说的话，感觉block是不是有点像代理了呢？ 我之前接触block，都是使用它作为函数参数，当时感觉不是很理解。现在在项目中，很多时候block作为property，这样更加简单直接，想想，其实property不就是定义的合成存储的变量嘛，而block作为函数参数也是定义的变量，所以作为函数参数或者作为property本质没有区别。 看一看别人总结的block的语法吧，http://fuckingblocksyntax.com，这个链接亮了，fucking block syntax，操蛋的block语法啊。block有如下几种使用情况， 1、作为一个本地变量（local variable） 123returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123; //blablabla&#125;; 2、作为@property 1@property (nonatomic, copy) returnType (^blockName)(parameterTypes); 3、作为方法的参数（method parameter） 1- (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; 4、作为方法参数的时候被调用 1[someObject someMethodThatTakesABlock: ^returnType (parameters) &#123;...&#125;]; 5、使用typedef来定义block，可以事半功倍 12typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123;...&#125;; 上面我也只是复制粘贴了一下，接下来还是实现点击CustomTableViewCell上面的Button实现页面跳转的功能，我之前不止一次的类比block就像delegate，这边我也是思维惯性，下面的内容我就当block为代理，一些用词描述还是跟delegate差不多。首先，在提出委托申请的CustomTableViewCell中定义block的property， 12345@interface CustomTableViewCell : UITableViewCell@property (nonatomic, strong) UILabel *text1Label;@property (nonatomic, strong) UIButton *detailBtn; 123456789/*delegate的定义 我没有删除，因为大家可以类比了看下*/@property (nonatomic, assign) id&lt;CustomCellDelegate&gt; delegate;/*这里定义了ButtonBlock*/@property (nonatomic, copy) void (^ButtonBlock)();@end 这里用copy属性来修饰ButtonBlock property，这个原因，我会在以后的博客中作专门的解释。 接下来在CustomTableViewCell中给它上面的detailBtn绑定点击方法， 12345678910111213[self.detailBtn addTarget:self action:@selector(btnClicked:) forControlEvents:UIControlEventTouchUpInside];- (void)btnClicked:(UIButton *)btn &#123; //这是之前的delegate if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(pushToNewPage)]) &#123; [self.delegate pushToNewPage]; &#125; //这是现在我们要说的block if (ButtonBlock) &#123; ButtonBlock(); &#125;&#125; 下面是一个关键性的地方，在ViewController2中设置其CustomTableViewCell的cell对象的ButtonBlock，也就是给它赋值，此处我还是保留了cell.delegate = self; ##代码## 12345678910111213141516- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; NSString *blockIdentify = @&quot;BlockIdentify&quot;; CustomTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:blockIdentify]; if (cell == nil) &#123; cell = [[CustomTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:blockIdentify]; &#125; cell.text1Label.text = [self.textArray objectAtIndex:indexPath.row]; //delegate的不可缺少的代码，这里放在这儿只是为了给各位类比一下 cell.delegate = self; //ButtonBlock不可缺少的代码 cell.ButtonBlock = ^&#123; [self pushToNewPage2]; &#125;; return cell;&#125; 之所以cell.ButtonBlock = ^{};赋值，是因为我们我们是这样定义ButtonBlock的，void (^ButtonBLock)()，表示无返回值无参数。 你们看这个方法是不是与CustomCellDelegate协议中的pushToNewPage方法类似。然后在回过头来类比一样，是不是block就是精简版的delegate，因为delegate设计模式要写协议CustomCellDelegate，还有容易遗漏cell.delegate = self;但是block使用的时候就简单多了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"block","slug":"block","permalink":"http://xiaoyu666.com/tags/block/"}]},{"title":"Docker容器配置gogs","slug":"Docker容器配置gogs","date":"2016-08-06T13:14:52.000Z","updated":"2018-07-09T03:40:15.606Z","comments":true,"path":"2016/08/06/Docker容器配置gogs/","link":"","permalink":"http://xiaoyu666.com/2016/08/06/Docker容器配置gogs/","excerpt":"","text":"#gogs介绍https://gogs.io/ #docker方式部署gogshttps://github.com/gogits/gogs/tree/master/docker 1234567891011# Pull image from Docker Hub.$ docker pull gogs/gogs# Create local directory for volume.$ mkdir -p /var/gogs# Use `docker run` for the first time.$ docker run --name=gogs -p 10022:22 -p 10080:3000 -v /var/gogs:/data gogs/gogs# Use `docker start` if you have stopped it.$ docker start gogs 将gogs运行端口绑定到3000端口后就ok了这样当nginx启动完成后反向代理就成功了","categories":[{"name":"linux","slug":"linux","permalink":"http://xiaoyu666.com/categories/linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://xiaoyu666.com/tags/docker/"},{"name":"gogs","slug":"gogs","permalink":"http://xiaoyu666.com/tags/gogs/"},{"name":"git","slug":"git","permalink":"http://xiaoyu666.com/tags/git/"}]},{"title":"oc下实现局域网udp广播通讯使用开源框架GCDAsyncUdpSocket","slug":"oc下实现局域网udp广播通讯使用开源框架GCDAsyncUdpSocket","date":"2016-03-29T13:11:10.000Z","updated":"2018-07-09T03:40:15.611Z","comments":true,"path":"2016/03/29/oc下实现局域网udp广播通讯使用开源框架GCDAsyncUdpSocket/","link":"","permalink":"http://xiaoyu666.com/2016/03/29/oc下实现局域网udp广播通讯使用开源框架GCDAsyncUdpSocket/","excerpt":"#UDP简介 UDP是OSI参考模型中一种无连接的传输层协议，它主要用于不要求分组顺序到达的传输中，分组传输顺序的检查与排序由应用层完成，提供面向事务的简单不可靠信息传送服务。","text":"#UDP简介 UDP是OSI参考模型中一种无连接的传输层协议，它主要用于不要求分组顺序到达的传输中，分组传输顺序的检查与排序由应用层完成，提供面向事务的简单不可靠信息传送服务。 UDP 协议基本上是IP协议与上层协议的接口。UDP协议适用端口分别运行在同一台设备上的多个应用程序。udp协议通信在发送数据包的时候是不用绑定端口的，系统会自动分配端口，只有在发送消息的时候才需要绑定端口。 网络上已经有编写好的开源类库GCDAsyncSocket 和GCDAsyncUdpSocket 这是GCD版的 比AsyncSocket 和AsyncUdpSocket估计要好用点 用法也很简单，跟http很类似 只要指定服务器的ip和端口 然后再实现各种回调就行。 socket默认情况下就是采用TCP协议，创建之后通信双方的socket会一直保持连接，除非手动close或因为网络原因close，所以，此种状况对服务器而言是有一定资源消耗的，这种模式只适应与对服务器小规模的访问，特别是对于实时性很高的应用，如视频直播、呼叫系统等，而http一般都是短连接的，一次请求完之后客户端便会于服务端端开连接http是凌驾于socket之上的高级协议，而socket是比较底层的通讯方式，只是建立了一个连接通道，具体上面传输什么样的数据，按照什么格式传输，需要你自己定义，所以这就需要重新编写定义服务端与客户端的所应遵循的规定，而http已经被前人们定义使用过了。 #####GCDAsyncUdpSocket ARC版下载地址(github) #代码 初始化GCDAsyncUdpSocket类 共有四个初始化方法。 12345678- (id)init;- (id)initWithSocketQueue:(dispatch_queue_t)sq;- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq;- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq; 在使用GCDAsyncUdpSocket传输数据前必须设置代理和代理队列，否则就会报错。 #####socketQueue是可选的，如果不设置系统会置为NULL，这样GCDAsyncUdpSocket会自动创建一个自己的socketqueue #####代理队列 delegateQueue和socketQueue可以一样。 这里已经绑定了delegate 不用在类声明中重复实现这个代理了。 #消息发送 若客户端只向服务端发送消息而不用接收到其他的udp消息就可以不用绑定端口 ##消息发送的方法 该方法只能用于已经连接了的Socket中 123456789101112- (void)sendData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag;该方法不能用于已经连接了socket中，只能用于没有长连接的socket中- (void)sendData:(NSData *)data toHost:(NSString *)host port:(uint16_t)portwithTimeout:(NSTimeInterval)timeout tag:(long)tag;该方法不能用于已经连接了socket中，只能用于没有长连接的socket中- (void)sendData:(NSData *)data toAddress:(NSData *)remoteAddr withTimeout:(NSTimeInterval)timeout tag:(long)tag; ##例子： 12345678910111213141516171819202122232425262728- (IBAction)sendToServer:(id)sender &#123; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;my1&quot;, @&quot;my1&quot;, @&quot;my2&quot;, @&quot;扣篮大赛&quot;, @&quot;my3&quot;, @&quot;贷记卡&quot;, @&quot;my4&quot;, @&quot;我到了&quot;, nil]; NSString *str = [[SBJson4Writer alloc]stringWithObject:dic]; NSLog(@&quot;%@&quot;,str); NSString *host = @&quot;224.0.0.1&quot;; int port = 3339; NSData *data = [msg dataUsingEncoding:NSUTF8StringEncoding];//host是在服务端设置的host，port也是服务端绑定的port，上文说过如果客户端不需要接收消息，就不用绑定端口 [udpSocket sendData:data toHost:host port:port withTimeout:-1 tag:tag]; NSLog(@&quot;SENT (%i): %@&quot;, (int)tag, msg); tag++;&#125; ##端口绑定和广播开启 方法： 以下方法用于服务端，客户端可以跳过 123456789101112131415161718//绑定端口- (BOOL)bindToPort:(uint16_t)port error:(NSError **)errPtr;- (BOOL)bindToPort:(uint16_t)port interface:(NSString *)interface error:(NSError **)errPtr;//绑定到一个地址，可不设置- (BOOL)bindToAddress:(NSData *)localAddr error:(NSError **)errPtr;//绑定到一个HOST和端口- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port error:(NSError **)errPtr;//开启广播，若不实现这个方法，默认是关闭的- (BOOL)enableBroadcast:(BOOL)flag error:(NSError **)errPtr; 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (IBAction)startServer:(id)sender &#123; int port = 3339; NSError *error = nil; if (![udpServer bindToPort:port error:&amp;error]) &#123; NSLog(@&quot;Error starting server (bind): %@&quot;, error); return; &#125; if (![udpServer enableBroadcast:YES error:&amp;error]) &#123; NSLog(@&quot;Error enableBroadcast (bind): %@&quot;, error); return; &#125; if (![udpServer joinMulticastGroup:@&quot;224.0.0.1&quot; error:&amp;error]) &#123; NSLog(@&quot;Error joinMulticastGroup (bind): %@&quot;, error); return; &#125; if (![udpServer beginReceiving:&amp;error]) &#123; [udpServer close]; NSLog(@&quot;Error starting server (recv): %@&quot;, error); return; &#125; NSLog(@&quot;udp servers success starting %hd&quot;, [udpServer localPort]); isRunning =true;&#125; ####特别说明： 若客户端也要实现接收到服务器发送的消息，也必须实现上述代码，只是不需要实现enableBraodcast:error:这个方法，这样在客户端就可以接收到消息了 另外，客户端的端口号不需要与服务端的端口号保持一致。这时候，从另外一个角度来说，客户端变成了一个简易的服务端。 ###代理方法 GCDAsyncUdpSocketDelegate 方法： 123456789101112131415161718192021222324//在绑定address成功后回调- (void)udpSocket:(GCDAsyncUdpSocket *)sock didConnectToAddress:(NSData *)address;- (void)udpSocket:(GCDAsyncUdpSocket *)sock didNotConnect:(NSError *)error;//发送消息后回调，不关心是否成功发送。- (void)udpSocket:(GCDAsyncUdpSocket *)sock didSendDataWithTag:(long)tag;- (void)udpSocket:(GCDAsyncUdpSocket *)sock didNotSendDataWithTag:(long)tag dueToError:(NSError *)error;//在接收到消息后回调这个方法- (void)udpSocket:(GCDAsyncUdpSocket *)sock didReceiveData:(NSData *)datafromAddress:(NSData *)addresswithFilterContext:(id)filterContext;//在Socket连接关闭后回调- (void)udpSocketDidClose:(GCDAsyncUdpSocket *)sock withError:(NSError *)error; ##例子： 服务端接收到消息： 12345678-(void)udpSocket:(GCDAsyncUdpSocket *)sock didReceiveData:(NSData *)data fromAddress:(NSData *)address withFilterContext:(id)filterContext&#123; NSLog(@&quot;%@%d&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],[sock connectedPort]); [udpServer sendData:data toAddress:address withTimeout:-1 tag:0];&#125; 这里做了两件事情，第一件事情是将接收到的消息打印出来，第二件事情就是重新发送一个消息给来源接收。这样目的是是发送端知道接收端己收到消息。从而做出相应的处理。 #####Demo下载(CSDN)","categories":[{"name":"iOS","slug":"iOS","permalink":"http://xiaoyu666.com/categories/iOS/"}],"tags":[{"name":"oc","slug":"oc","permalink":"http://xiaoyu666.com/tags/oc/"},{"name":"socket","slug":"socket","permalink":"http://xiaoyu666.com/tags/socket/"},{"name":"GCDAsyncUdpSocket","slug":"GCDAsyncUdpSocket","permalink":"http://xiaoyu666.com/tags/GCDAsyncUdpSocket/"},{"name":"tcp","slug":"tcp","permalink":"http://xiaoyu666.com/tags/tcp/"}]}]}